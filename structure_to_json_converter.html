<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBT to Blockbench Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/binpacking@0.0.1/dist/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.bunny.net/css?family=nunito:200,300,400,500,600,700,800,900" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Minecraft Ten';
            src: url('assets/fonts/minecraft.woff2') format('woff2'),
                url('assets/fonts/minecraft.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        img {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }

        body {
            font-family: 'Nunito', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-image: url('assets/home/background.png');
            background-color: #2d2d2d;
            background-size: auto;
            background-repeat: repeat;
            background-position: top left;
            color: #e6e6e6;
            line-height: 1.4;
            min-height: 100vh;
            overflow-x: hidden;
        }

        a:link {
            color: #3453df;
            text-decoration: none;
        }

        a:visited {
            color: #3453df;
            text-decoration: none;
        }

        a:hover {
            color: #5a73ff;
            text-decoration: underline;
        }

        a:active {
            color: #2a42bf;
        }

        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0a;
            border: 2px solid #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #48494a;
            border: 2px solid #1a1a1a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5b5c;
        }

        .header {
            background: rgba(45, 45, 45, 1.0);
            border-bottom: 3px solid #4a4a4a;
            padding: 15px 0;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 100;
            margin-bottom: 20px;
        }

        .header-content {
            max-width: 95vw;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
        }

        .logo {
            height: 60px;
            width: auto;
        }

        .logo img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }

        .main-wrapper {
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #262626;
            border: none;
            padding: 30px;
        }

        .page-title {
            font-size: 28px;
            margin-bottom: 10px;
            color: #3453df;
            border-bottom: 2px solid #4a4a4a;
            padding-bottom: 15px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .subtitle {
            color: #a0a0a0;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            position: relative;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424;
        }

        .section h2 {
            color: #3453df;
            margin-bottom: 15px;
            font-size: 20px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .info-box {
            background: #1a1a1a;
            border-left: 4px solid #3453df;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #cccccc;
        }

        .info-box h4 {
            margin-bottom: 10px;
            color: #3453df;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .upload-card {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            padding: 20px;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424;
        }

        .upload-card h3 {
            color: #3453df;
            margin-bottom: 15px;
            font-size: 18px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .file-info {
            margin-top: 10px;
            padding: 12px;
            background: #1a1a1a;
            border-left: 4px solid #3a8b4a;
            font-size: 13px;
            line-height: 1.6;
        }

        .file-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .file-info-row:last-child {
            margin-bottom: 0;
        }

        .file-info-label {
            color: #a0a0a0;
        }

        .file-info-value {
            color: #e6e6e6;
            font-weight: 600;
        }

        .mod-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .mod-card {
            background: #1a1a1a;
            padding: 15px;
            border: 2px solid #0a0a0a;
            position: relative;
        }

        .mod-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .mod-card-title {
            color: #3453df;
            font-weight: 600;
            font-size: 15px;
        }

        .mod-card-info {
            font-size: 12px;
            line-height: 1.6;
            color: #a0a0a0;
        }

        .mod-card-info strong {
            color: #e6e6e6;
        }

        .usage-section {
            background: #1a1a1a;
            border-left: 4px solid #3453df;
            padding: 20px;
            margin-bottom: 30px;
        }

        .usage-section h3 {
            color: #3453df;
            margin-bottom: 15px;
            font-size: 18px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .usage-steps {
            list-style: none;
            counter-reset: step-counter;
        }

        .usage-steps li {
            counter-increment: step-counter;
            margin-bottom: 12px;
            padding-left: 35px;
            position: relative;
            line-height: 1.6;
        }

        .usage-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #3453df;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Minecraft Ten', sans-serif;
        }

        @media (max-width: 768px) {
            .upload-grid {
                grid-template-columns: 1fr;
            }

            .mod-grid {
                grid-template-columns: 1fr;
            }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 0;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }

        .toast {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            padding: 15px 20px;
            min-width: 250px;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: slideInRight 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            border-radius: 0;
        }

        .toast.success {
            border-left: 4px solid #3a8b4a;
        }

        .toast.error {
            border-left: 4px solid #8b3a3a;
        }

        .toast.info {
            border-left: 4px solid #3453df;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-icon {
            font-size: 20px;
        }

        .toast.success .toast-icon {
            color: #3a8b4a;
        }

        .toast.error .toast-icon {
            color: #8b3a3a;
        }

        .toast.info .toast-icon {
            color: #3453df;
        }

        .toast-message {
            color: #e6e6e6;
            font-size: 14px;
        }

        .help-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: none;
            user-select: none;
            background: none;
            padding: 0;
            z-index: 100;
        }

        .help-button-left-outline {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            bottom: 0;
            background: #1e1e1e;
            z-index: 5;
            transition: transform 0.15s ease;
        }

        .help-button-right-outline {
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            bottom: 0;
            background: #1e1e1e;
            z-index: 5;
            transition: transform 0.15s ease;
        }

        .help-button-section {
            flex: 1;
            background: #48494a;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 1px 1px 0 #6c6d6d, inset -1px -1px 0 #5b5c5c;
            overflow: hidden;
            z-index: 2;
            transition: transform 0.15s ease;
            margin: 0 2px;
            margin-bottom: 0;
            border-top: 2px solid #1e1e1e;
        }

        .help-button-dark-strip {
            height: 8px;
            background: #3b3c3c;
            position: relative;
            z-index: 2;
            transition: transform 0.15s ease, opacity 0.15s ease;
            margin: 0 2px;
            margin-top: 0;
        }

        .help-button-bottom-outline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #1e1e1e;
            z-index: 5;
        }

        .help-button-shadow {
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: #1a1a1a;
            z-index: 1;
            transition: transform 0.15s ease, opacity 0.15s ease;
        }

        .help-button-text {
            color: white;
            font-size: 32px;
            font-family: 'Minecraft Ten', sans-serif;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            position: relative;
            z-index: 2;
        }

        .help-button.pressed .help-button-section {
            transform: translateY(6px);
        }

        .help-button.pressed .help-button-left-outline,
        .help-button.pressed .help-button-right-outline {
            transform: translateY(6px);
        }

        .help-button.pressed .help-button-dark-strip,
        .help-button.pressed .help-button-shadow {
            transform: translateY(3px);
            opacity: 0;
        }

        .help-button:hover .help-button-section {
            background: #414242;
        }

        .help-button:hover .help-button-dark-strip {
            background: #323333;
        }

        .help-modal {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .help-modal-header {
            padding: 20px;
            border-bottom: 2px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-modal-title {
            color: #3453df;
            font-size: 22px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .help-modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
            font-family: 'Nunito', sans-serif;
            line-height: 1.8;
            font-size: 15px;
            color: #e6e6e6;
        }

        .help-modal-body h3 {
            color: #3453df;
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .help-modal-body h3:first-child {
            margin-top: 0;
        }

        .help-modal-body p {
            margin-bottom: 15px;
        }

        .help-modal-body ol,
        .help-modal-body ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .help-modal-body li {
            margin-bottom: 8px;
        }

        .help-modal-body strong {
            color: #3453df;
        }

        .help-modal-body code {
            background: #1a1a1a;
            padding: 2px 6px;
            color: #3453df;
            font-family: 'Courier New', monospace;
            word-break: break-word;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-close {
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            margin: 0;
        }

        .modal-close img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .help-button {
                bottom: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
            }

            .help-button-text {
                font-size: 28px;
            }

            .help-modal {
                width: 95%;
            }
        }

        .upload-zone {
            border: 3px dashed #3453df;
            padding: 40px;
            text-align: center;
            background: #1a1a1a;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        .upload-zone:hover {
            background: #242424;
            border-color: #5a73ff;
        }

        .upload-zone.dragover {
            background: #2a2a3a;
            border-color: #5a73ff;
        }

        input[type="file"] {
            display: none;
        }

        .file-status {
            margin-top: 10px;
            padding: 10px;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            font-size: 14px;
        }

        .file-status.success {
            border-left: 4px solid #3a8b4a;
        }

        .mod-list {
            margin-top: 15px;
        }

        .mod-item {
            background: #1a1a1a;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid #0a0a0a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mod-item strong {
            color: #3453df;
        }

        .minecraft-button {
            cursor: pointer;
            height: 45px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            border: none;
            user-select: none;
            background: none;
            padding: 0;
            min-width: 200px;
        }

        .minecraft-button-left-outline {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            bottom: 0;
            background: #1e1e1e;
            z-index: 5;
            transition: transform 0.15s ease;
        }

        .minecraft-button-right-outline {
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            bottom: 0;
            background: #1e1e1e;
            z-index: 5;
            transition: transform 0.15s ease;
        }

        .minecraft-button-section {
            flex: 1;
            background: #48494a;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 1px 1px 0 #6c6d6d, inset -1px -1px 0 #5b5c5c;
            overflow: hidden;
            z-index: 2;
            transition: transform 0.15s ease;
            margin: 0 2px;
            margin-bottom: 0;
            border-top: 2px solid #1e1e1e;
        }

        .minecraft-button-dark-strip {
            height: 8px;
            background: #3b3c3c;
            position: relative;
            z-index: 2;
            transition: transform 0.15s ease, opacity 0.15s ease;
            margin: 0 2px;
            margin-top: 0;
        }

        .minecraft-button-bottom-outline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #1e1e1e;
            z-index: 5;
        }

        .minecraft-button-shadow {
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: #1a1a1a;
            z-index: 1;
            transition: transform 0.15s ease, opacity 0.15s ease;
        }

        .minecraft-button-name {
            font-size: 15px;
            color: #ffffff;
            font-family: 'Minecraft Ten', sans-serif;
            position: relative;
            z-index: 2;
            white-space: nowrap;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
            padding: 0 20px;
        }

        .minecraft-button.pressed .minecraft-button-section {
            transform: translateY(6px);
        }

        .minecraft-button.pressed .minecraft-button-left-outline,
        .minecraft-button.pressed .minecraft-button-right-outline {
            transform: translateY(6px);
        }

        .minecraft-button.pressed .minecraft-button-dark-strip,
        .minecraft-button.pressed .minecraft-button-shadow {
            transform: translateY(3px);
            opacity: 0;
        }

        .minecraft-button:hover .minecraft-button-section {
            background: #414242;
        }

        .minecraft-button:hover .minecraft-button-dark-strip {
            background: #323333;
        }

        .minecraft-button.small {
            height: 35px;
            min-width: 150px;
        }

        .minecraft-button.small .minecraft-button-name {
            font-size: 13px;
            padding: 0 15px;
        }

        .minecraft-button.success .minecraft-button-section {
            background: #3a8b4a;
            box-shadow: inset 1px 1px 0 #58c169, inset -1px -1px 0 #4fb35f;
        }

        .minecraft-button.success:hover .minecraft-button-section {
            background: #2d6b3a;
        }

        .minecraft-button.success .minecraft-button-dark-strip {
            background: #2a6b35;
        }

        .minecraft-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .minecraft-button:disabled:hover .minecraft-button-section {
            background: #48494a;
        }

        .minecraft-button:disabled {
            cursor: not-allowed;
        }

        .minecraft-button:disabled .minecraft-button-section {
            background: #8b3a3a;
            box-shadow: inset 1px 1px 0 #b35f5f, inset -1px -1px 0 #a04e4e;
        }

        .minecraft-button:disabled .minecraft-button-dark-strip {
            background: #6b2525;
        }

        .minecraft-button:disabled:hover .minecraft-button-section {
            background: #a04444;
        }

        .minecraft-button:disabled:hover .minecraft-button-dark-strip {
            background: #7b3030;
        }

        .minecraft-button:disabled.pressed .minecraft-button-section,
        .minecraft-button:disabled.pressed .minecraft-button-left-outline,
        .minecraft-button:disabled.pressed .minecraft-button-right-outline,
        .minecraft-button:disabled.pressed .minecraft-button-dark-strip,
        .minecraft-button:disabled.pressed .minecraft-button-shadow {
            transform: none;
            opacity: 1;
        }

        .progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .progress-overlay.show {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        .progress-box {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            padding: 30px 40px;
            min-width: 350px;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .progress-title {
            color: #3453df;
            font-size: 20px;
            font-family: 'Minecraft Ten', sans-serif;
            margin-bottom: 20px;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            box-shadow: inset 1px 1px 0 #2a2a2a;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: #3453df;
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: inset 1px 1px 0 #5a73ff;
            position: relative;
        }

        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(90deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.1) 10px,
                    rgba(255, 255, 255, 0.1) 20px);
            animation: progress-stripes 1s linear infinite;
        }

        @keyframes progress-stripes {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 20px 0;
            }
        }

        .progress-text {
            color: #e6e6e6;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-percentage {
            color: #3453df;
            font-size: 24px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .download-section {
            margin-top: 30px;
            padding: 20px;
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            position: relative;
            display: none;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424;
        }

        .download-section.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .download-content {
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .download-info {
            color: #cccccc;
            margin: 15px 0;
            font-size: 16px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .texture-dropdown {
            margin-top: 30px;
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            position: relative;
            min-height: 60px;
            transition: all 0.3s ease;
            user-select: none;
        }

        .texture-dropdown::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .texture-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            cursor: pointer;
            position: relative;
            background: transparent;
        }

        .texture-dropdown.expanded .texture-header {
            border-bottom: 2px solid #1a1a1a;
        }

        .texture-header-text {
            position: relative;
            z-index: 2;
            font-size: 18px;
            color: #3453df;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .texture-header-arrow {
            width: 15px;
            height: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.4s ease;
            transform: rotate(0deg);
            position: relative;
            z-index: 2;
        }

        .texture-header-arrow img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .texture-grid {
            position: relative;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #2e2e2e;
        }

        .texture-grid.open {
            max-height: 600px;
            overflow-y: auto;
        }

        .texture-content {
            position: relative;
            z-index: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .texture-item {
            background: #3a3a3a;
            border: 2px solid #1a1a1a;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: inset 1px 1px 0 #4a4a4a, inset -1px -1px 0 #2a2a2a;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .texture-item:hover {
            background: #424242;
            border-color: #3453df;
        }

        .texture-preview {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            background: #2a2a2a;
            border: 2px solid #1a1a1a;
            margin-bottom: 8px;
        }

        .texture-name {
            font-size: 11px;
            color: #cccccc;
            text-align: center;
            word-break: break-word;
        }

        .texture-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .texture-modal-overlay.show {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        .texture-modal {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            max-width: 600px;
            width: 90%;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .texture-modal-header {
            padding: 15px 20px;
            border-bottom: 2px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #343231;
        }

        .texture-modal-title {
            color: #3453df;
            font-size: 18px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .texture-modal-body {
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .texture-modal-image {
            max-width: 100%;
            max-height: 400px;
            image-rendering: pixelated;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            min-width: 256px;
            min-height: 256px;
            object-fit: contain;
        }

        .texture-modal-canvas {
            image-rendering: pixelated;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            min-width: 256px;
            min-height: 256px;
        }

        .texture-preview {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            background: #2a2a2a;
            border: 2px solid #1a1a1a;
            margin-bottom: 8px;
        }

        .animated-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #3453df;
            color: white;
            padding: 2px 6px;
            font-size: 9px;
            font-weight: bold;
            font-family: 'Minecraft Ten', sans-serif;
            border: 1px solid #1a1a1a;
            z-index: 10;
        }

        .texture-modal-footer {
            padding: 15px 20px;
            border-top: 2px solid #1a1a1a;
            display: flex;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .texture-content {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid;
        }

        .status.info {
            background: #1a2a3a;
            color: #5a9fff;
            border-color: #3453df;
            display: block;
        }

        .status.success {
            background: #1a3a2a;
            color: #58c169;
            border-color: #3a8b4a;
            display: block;
        }

        .status.error {
            background: #3a1a1a;
            color: #ff5a5a;
            border-color: #8b3a3a;
            display: block;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 35px;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3453df 0%, #5a73ff 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            margin-bottom: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: #2a2a2a;
        }

        .stat-number {
            font-size: 32px;
            color: #3453df;
            font-family: 'Minecraft Ten', sans-serif;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: #a0a0a0;
        }

        @media (max-width: 768px) {
            .stats-bar {
                grid-template-columns: 1fr;
            }

            .minecraft-button {
                width: 100%;
            }
        }

        .box-uv-container {
            margin-bottom: 20px;
            padding: 15px;
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424;
        }

        .box-uv-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: #e6e6e6;
            font-size: 14px;
            font-weight: 600;
        }

        .box-uv-description {
            color: #a0a0a0;
            font-size: 12px;
            margin-top: 8px;
            margin-left: 26px;
            line-height: 1.5;
        }

        input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            appearance: none;
            -webkit-appearance: none;
            background-image: url('assets/buttons/checkbox.png');
            background-size: 16px 16px;
            background-repeat: no-repeat;
            background-position: center;
            border: none;
            box-shadow: none;
            background-color: transparent;
            border-radius: 0;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        input[type="checkbox"]:checked {
            background-image: url('assets/buttons/checkboxchecked.png');
        }

        .preview-modal {
            background: #2e2e2e;
            border: 2px solid #1a1a1a;
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .preview-modal-header {
            padding: 20px;
            border-bottom: 2px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #343231;
            flex-shrink: 0;
        }

        .preview-modal-title {
            color: #3453df;
            font-size: 20px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .preview-modal-body {
            display: flex;
            flex-direction: row;
            overflow: hidden;
            background: #1a1a1a;
            position: relative;
            flex: 1;
        }

        #previewCanvas {
            flex: 1;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        #previewCanvas canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        .preview-controls {
            padding: 15px;
            background: #2a2a2a;
            border-top: 2px solid #1a1a1a;
            flex-shrink: 0;
            width: 100%;
            z-index: 11;
        }

        .preview-info {
            color: #cccccc;
            font-size: 14px;
            text-align: center;
            font-family: 'Minecraft Ten', sans-serif;
        }

        @media (max-width: 768px) {
            .preview-modal {
                width: 95vw;
                height: 95vh;
            }
        }

        .preview-settings-panel {
            width: 0;
            min-width: 0;
            background: #2e2e2e;
            border-right: 2px solid #1a1a1a;
            border-left: none;
            transition: width 0.3s ease;
            z-index: 10;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .preview-viewport-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 0;
            transition: transform 0.3s ease;
        }

        .preview-settings-tab {
            position: absolute;
            left: 0;
            top: -1px;
            width: 40px;
            height: 40px;
            background: #48494a;
            border: 2px solid #1e1e1e;
            border-left: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: inset 1px 1px 0 #6c6d6d, inset -1px -1px 0 #5b5c5c;
            border-radius: 0;
        }

        .preview-modal-body {
            padding: 40;
            overflow-y: auto;
            flex: 1;
            background: #1a1a1a;
            position: relative;
        }

        .preview-settings-tab:hover {
            background: #414242;
        }

        .preview-settings-tab img {
            width: 20px;
            height: 20px;
            image-rendering: pixelated;
            transform: rotate(90deg);
            transition: transform 0.3s ease;
        }

        .preview-settings-panel.open+.preview-viewport-wrapper .preview-settings-tab img {
            transform: rotate(-90deg);
        }

        .preview-settings-header {
            padding: 15px;
            background: #343231;
            border-bottom: 2px solid #1a1a1a;
            color: #3453df;
            font-family: 'Minecraft Ten', sans-serif;
            font-size: 16px;
            white-space: nowrap;
        }

        .preview-settings-panel.open {
            width: 250px;
        }

        .preview-settings-toggle {
            transition: transform 0.3s ease;
        }

        .preview-settings-panel.open .preview-settings-toggle {
            transform: rotate(180deg);
        }

        .preview-settings-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            min-width: 250px;
        }

        .preview-setting-group {
            margin-bottom: 20px;
        }

        .preview-setting-label {
            display: block;
            color: #cccccc;
            font-size: 13px;
            margin-bottom: 8px;
            font-family: 'Minecraft Ten', sans-serif;
        }

        .preview-color-input {
            width: 100%;
            height: 35px;
            border: 2px solid #1a1a1a;
            background: #1a1a1a;
            cursor: pointer;
        }

        .preview-checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #cccccc;
            font-size: 13px;
            cursor: pointer;
        }

        .preview-angle-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            width: 100%;
        }

        .preview-angle-buttons .minecraft-button.small {
            min-width: 80px !important;
            max-width: 100px !important;
            padding: 0 !important;
            height: 32px;
        }

        .preview-angle-button {
            height: 35px;
            min-width: 0;
            max-width: 10px;
        }

        .preview-angle-button .minecraft-button-name {
            font-size: 11px;
            padding: 0 10px;
        }

        .preview-screenshot-button {
            width: 100%;
            height: 40px;
        }

        select.preview-color-input {
            color: #e6e6e6;
            font-family: 'Minecraft Ten', sans-serif;
            font-size: 13px;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 2px solid #0a0a0a;
            box-shadow: inset 1px 1px 0 #2a2a2a;
            cursor: pointer;
        }

        select.preview-color-input:hover {
            background: #242424;
            border-color: #3453df;
        }

        select.preview-color-input:focus {
            outline: none;
            border-color: #3453df;
        }

        select.preview-color-input option {
            background: #1a1a1a;
            color: #e6e6e6;
            padding: 8px;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .screenshot-texture-item {
            background: #2a2a2a;
            border: 2px solid #1a1a1a;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .screenshot-texture-item:hover {
            background: #3a3a3a;
            border-color: #3453df;
        }

        .screenshot-texture-item.selected {
            background: #2a3a4a;
            border-color: #3453df;
        }

        .screenshot-texture-preview {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            background: #1a1a1a;
            border: 1px solid #0a0a0a;
        }

        .screenshot-texture-name {
            font-size: 10px;
            color: #a0a0a0;
            text-align: center;
            word-break: break-word;
            max-width: 100%;
            font-family: 'Segoe UI', sans-serif;
        }

        .preview-color-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .preview-color-row label {
            font-size: 12px;
            color: #cccccc;
            flex: 1;
        }

        .preview-color-row input[type="color"] {
            width: 60px;
            height: 30px;
            border: 2px solid #1a1a1a;
            background: #1a1a1a;
            cursor: pointer;
            padding: 2px;
        }
    </style>
</head>
<body>
<div class="header">
    <div class="header-content">
        <div class="logo">
            <a href="https://potatowolfie.github.io">
                <img src="assets/home/logo.png" alt="PotatoWolfie">
            </a>
        </div>
    </div>
</div>

<div class="main-wrapper">
    <div class="container">
        <h1 class="page-title">NBT to Blockbench Converter</h1>
        <p class="subtitle">Convert Minecraft structure files to Blockbench models</p>

        <div class="upload-grid">
            <div class="upload-card">
                <h3>Minecraft Resources</h3>
                <div class="upload-zone" id="resourceZone" onclick="document.getElementById('resourceZip').click()">
                    <div style="font-size: 18px; color: #3453df; margin-bottom: 5px;">Click or drag .jar/.zip file here</div>
                    <div style="font-size: 14px; color: #a0a0a0;">Minecraft client JAR or resource pack</div>
                </div>
                <input type="file" id="resourceZip" accept=".zip,.jar">
                <div id="resourceInfo" style="display: none;"></div>
            </div>

            <div class="upload-card">
                <h3>NBT Structure File</h3>
                <div class="upload-zone" id="nbtZone" onclick="document.getElementById('nbtFile').click()">
                    <div style="font-size: 18px; color: #3453df; margin-bottom: 5px;">Click or drag .nbt file here</div>
                    <div style="font-size: 14px; color: #a0a0a0;">Minecraft structure file</div>
                </div>
                <input type="file" id="nbtFile" accept=".nbt">
                <div id="nbtInfo" style="display: none;"></div>
            </div>
        </div>

        <div class="section">
            <h2>Modded Resources (Optional)</h2>
            <p style="font-size: 13px; color: #a0a0a0; margin-bottom: 15px;">Add mod JARs to support modded blocks in your structure</p>
            <button class="minecraft-button small" onclick="document.getElementById('modZip').click()">
                <div class="minecraft-button-left-outline"></div>
                <div class="minecraft-button-right-outline"></div>
                <div class="minecraft-button-section">
                    <div class="minecraft-button-name">+ Add Mod JAR</div>
                </div>
                <div class="minecraft-button-dark-strip"></div>
                <div class="minecraft-button-bottom-outline"></div>
                <div class="minecraft-button-shadow"></div>
            </button>
            <input type="file" id="modZip" accept=".zip,.jar" multiple>
            <div class="mod-grid" id="modList"></div>
        </div>

        <div id="statsSection" style="display: none;">
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-number" id="blockCount">0</div>
                    <div class="stat-label">Blocks</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="elementCount">0</div>
                    <div class="stat-label">Elements</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="textureCountStat">0</div>
                    <div class="stat-label">Textures</div>
                </div>
            </div>
        </div>

        <div class="section" style="padding: 15px; margin-bottom: 20px;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: #e6e6e6; font-size: 14px;">
                <input type="checkbox" id="greedyMeshCheckbox" style="width: 18px; height: 18px; cursor: pointer;">
                <span style="user-select: none;">
                    <strong style="color: #3453df;">Enable Mesh Optimization</strong>
                    <span style="color: #a0a0a0;">(Recommended for large structures - dramatically reduces cube count)</span>
                </span>
            </label>
            <div style="margin-top: 8px; padding-left: 28px; font-size: 12px; color: #888;">
                Merges adjacent blocks with same texture into larger faces. A 48x48x48 hollow cube becomes 6 faces instead of 110,592 cubes!
            </div>
        </div>

        <button class="minecraft-button success" id="convertBtn" disabled onclick="convertStructure()">
            <div class="minecraft-button-left-outline"></div>
            <div class="minecraft-button-right-outline"></div>
            <div class="minecraft-button-section">
                <div class="minecraft-button-name">Convert</div>
            </div>
            <div class="minecraft-button-dark-strip"></div>
            <div class="minecraft-button-bottom-outline"></div>
            <div class="minecraft-button-shadow"></div>
        </button>

        <div class="download-section" id="downloadSection">
            <div class="download-content">
                <div class="download-info">Your model is ready!</div>

                <div class="button-group">
                    <button class="minecraft-button success" onclick="downloadModel()">
                        <div class="minecraft-button-left-outline"></div>
                        <div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section">
                            <div class="minecraft-button-name">Download Model</div>
                        </div>
                        <div class="minecraft-button-dark-strip"></div>
                        <div class="minecraft-button-bottom-outline"></div>
                        <div class="minecraft-button-shadow"></div>
                    </button>

                    <button class="minecraft-button" onclick="previewModel()">
                        <div class="minecraft-button-left-outline"></div>
                        <div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section">
                            <div class="minecraft-button-name">Preview Model</div>
                        </div>
                        <div class="minecraft-button-dark-strip"></div>
                        <div class="minecraft-button-bottom-outline"></div>
                        <div class="minecraft-button-shadow"></div>
                    </button>
                </div>

                <div class="texture-dropdown" id="textureDropdown">
                    <div class="texture-header" onclick="toggleTextureDropdown()">
                        <div class="texture-header-text">Textures (<span id="textureCount">0</span>)</div>
                        <div class="texture-header-arrow" id="textureArrow">
                            <img src="assets/wiki/buttons/dropdown_arrow.png" alt="Dropdown Arrow">
                        </div>
                    </div>
                    <div class="texture-grid" id="textureGrid">
                        <div class="texture-content" id="textureContent"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="texture-modal-overlay" id="textureModalOverlay" onclick="closeTextureModal(event)">
            <div class="texture-modal" onclick="event.stopPropagation()">
                <div class="texture-modal-header">
                    <div class="texture-modal-title" id="textureModalTitle">Texture</div>
                    <button class="modal-close" onclick="closeTextureModal()">
                        <img src="assets/buttons/exit.png" alt="Close">
                    </button>
                </div>
                <div class="texture-modal-body">
                </div>
                <div class="texture-modal-footer">
                    <button class="minecraft-button success" onclick="downloadCurrentTexture()">
                        <div class="minecraft-button-left-outline"></div>
                        <div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section">
                            <div class="minecraft-button-name">Download Texture</div>
                        </div>
                        <div class="minecraft-button-dark-strip"></div>
                        <div class="minecraft-button-bottom-outline"></div>
                        <div class="minecraft-button-shadow"></div>
                    </button>
                </div>
            </div>
        </div>

        <div class="toast-container" id="toastContainer"></div>
    </div>
</div>

<div class="help-button" onclick="showHelp()">
    <div class="help-button-left-outline"></div>
    <div class="help-button-right-outline"></div>
    <div class="help-button-section">
        <div class="help-button-text">?</div>
    </div>
    <div class="help-button-dark-strip"></div>
    <div class="help-button-bottom-outline"></div>
    <div class="help-button-shadow"></div>
</div>

<div class="progress-overlay" id="progressOverlay">
    <div class="progress-box">
        <div class="progress-title">Converting Structure...</div>
        <div class="progress-bar-container">
            <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
        <div class="progress-text" id="progressText">Preparing...</div>
        <div class="progress-percentage" id="progressPercentage">0%</div>
    </div>
</div>

<div class="modal-overlay" id="helpModalOverlay" onclick="closeHelpModal(event)">
    <div class="help-modal" onclick="event.stopPropagation()">
        <div class="help-modal-header">
            <div class="help-modal-title">Help</div>
            <button class="modal-close" onclick="closeHelpModal()">
                <img src="assets/buttons/exit.png" alt="Close">
            </button>
        </div>
        <div class="help-modal-body" id="helpModalBody"></div>
    </div>
</div>
<script>
    /******************************************************************************

This is a very simple binary tree based bin packing algorithm that is initialized
with a fixed width and height and will fit each block into the first node where
it fits and then split that node into 2 parts (down and right) to track the
remaining whitespace.

Best results occur when the input blocks are sorted by height, or even better
when sorted by max(width,height).

Inputs:
------

w:       width of target rectangle
h:      height of target rectangle
blocks: array of any objects that have .w and .h attributes

Outputs:
-------

marks each block that fits with a .fit attribute pointing to a
node with .x and .y coordinates

Example:
-------

var blocks = [
{ w: 100, h: 100 },
{ w: 100, h: 100 },
{ w:  80, h:  80 },
{ w:  80, h:  80 },
etc
etc
];

var packer = new GrowingPacker();
packer.fit(blocks);

for(var n = 0 ; n < blocks.length ; n++) {
var block = blocks[n];
if (block.fit) {
Draw(block.fit.x, block.fit.y, block.w, block.h);
}
}

******************************************************************************/
    GrowingPacker = function() {};
    GrowingPacker.prototype = {
        fit: function(blocks) {
            var n, node, block, len = blocks.length;
            var w = len > 0 ? blocks[0].w : 0;
            var h = len > 0 ? blocks[0].h : 0;
            this.root = {
                x: 0,
                y: 0,
                w: w,
                h: h
            };
            for (n = 0; n < len; n++) {
                block = blocks[n];
                if (node = this.findNode(this.root, block.w, block.h))
                    block.fit = this.splitNode(node, block.w, block.h);
                else
                    block.fit = this.growNode(block.w, block.h);
            }
        },
        findNode: function(root, w, h) {
            if (root.used)
                return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);
            else if ((w <= root.w) && (h <= root.h))
                return root;
            else
                return null;
        },
        splitNode: function(node, w, h) {
            node.used = true;
            node.down = {
                x: node.x,
                y: node.y + h,
                w: node.w,
                h: node.h - h
            };
            node.right = {
                x: node.x + w,
                y: node.y,
                w: node.w - w,
                h: h
            };
            return node;
        },
        growNode: function(w, h) {
            var canGrowDown = (w <= this.root.w);
            var canGrowRight = (h <= this.root.h);
            var shouldGrowRight = canGrowRight && (this.root.h >= (this.root.w + w)); // attempt to keep square-ish by growing right when height is much greater than width
            var shouldGrowDown = canGrowDown && (this.root.w >= (this.root.h + h)); // attempt to keep square-ish by growing down  when width  is much greater than height
            if (shouldGrowRight)
                return this.growRight(w, h);
            else if (shouldGrowDown)
                return this.growDown(w, h);
            else if (canGrowRight)
                return this.growRight(w, h);
            else if (canGrowDown)
                return this.growDown(w, h);
            else
                return null; // need to ensure sensible root starting size to avoid this happening
        },
        growRight: function(w, h) {
            this.root = {
                used: true,
                x: 0,
                y: 0,
                w: this.root.w + w,
                h: this.root.h,
                down: this.root,
                right: {
                    x: this.root.w,
                    y: 0,
                    w: w,
                    h: this.root.h
                }
            };
            var node;
            if (node = this.findNode(this.root, w, h))
                return this.splitNode(node, w, h);
            else
                return null;
        },
        growDown: function(w, h) {
            this.root = {
                used: true,
                x: 0,
                y: 0,
                w: this.root.w,
                h: this.root.h + h,
                down: {
                    x: 0,
                    y: this.root.h,
                    w: this.root.w,
                    h: h
                },
                right: this.root
            };
            var node;
            if (node = this.findNode(this.root, w, h))
                return this.splitNode(node, w, h);
            else
                return null;
        }
    }
</script>
<script>
    // Put this at around 1455 once it works
    /*
    <div class="box-uv-container">
            <label class="box-uv-label">
                <input type="checkbox" id="boxUVCheckbox">
                <span>Convert to Box UV</span>
            </label>
            <div class="box-uv-description">
                idk box uv what do you want from me
            </div>
        </div>
        */
    let generatedZip = null;
    let generatedModel = null;
    let textureMap = new Map();
    let usedTextures = new Map();
    let currentTextureName = '';
    let currentTextureBlob = null;
    let textureTargetRotation = 0;
    let textureCurrentRotation = 0;
    let isTextureArrowAnimating = false;
    let missingBlocksData = null;
    let missingBlocksResolver = null;
    let previewScene = null;
    let previewCamera = null;
    let previewRenderer = null;
    let previewControls = null;
    let previewAnimationFrame = null;
    let animatedTextures = new Map();
    let screenshotBgType = 'transparent';
    let screenshotBgScale = 1.0;
    let screenshotBgTexture = null;
    let screenshotBgImage = null;

    class NBTParser {
        constructor(buffer) {
            this.buffer = new Uint8Array(buffer);
            this.offset = 0;
        }
        readByte() {
            return this.buffer[this.offset++];
        }
        readShort() {
            const value = (this.buffer[this.offset] << 8) | this.buffer[this.offset + 1];
            this.offset += 2;
            return value;
        }
        readInt() {
            const value = (this.buffer[this.offset] << 24) |
                (this.buffer[this.offset + 1] << 16) |
                (this.buffer[this.offset + 2] << 8) |
                this.buffer[this.offset + 3];
            this.offset += 4;
            return value;
        }
        readLong() {
            const high = this.readInt();
            const low = this.readInt();
            return (high * 4294967296) + (low >>> 0);
        }
        readFloat() {
            const view = new DataView(this.buffer.buffer, this.offset, 4);
            this.offset += 4;
            return view.getFloat32(0, false);
        }
        readDouble() {
            const view = new DataView(this.buffer.buffer, this.offset, 8);
            this.offset += 8;
            return view.getFloat64(0, false);
        }
        readByteArray() {
            const length = this.readInt();
            const array = Array.from(this.buffer.slice(this.offset, this.offset + length));
            this.offset += length;
            return array;
        }
        readIntArray() {
            const length = this.readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(this.readInt());
            }
            return array;
        }
        readLongArray() {
            const length = this.readInt();
            const array = [];
            for (let i = 0; i < length; i++) {
                array.push(this.readLong());
            }
            return array;
        }
        readString() {
            const length = this.readShort();
            const bytes = this.buffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return new TextDecoder().decode(bytes);
        }
        readCompound() {
            const compound = {};
            while (true) {
                const type = this.readByte();
                if (type === 0) break;
                const name = this.readString();
                compound[name] = this.readTag(type);
            }
            return compound;
        }
        readList() {
            const type = this.readByte();
            const length = this.readInt();
            const list = [];
            for (let i = 0; i < length; i++) {
                list.push(this.readTag(type));
            }
            return list;
        }
        readTag(type) {
            switch (type) {
                case 1:
                    return this.readByte();
                case 2:
                    return this.readShort();
                case 3:
                    return this.readInt();
                case 4:
                    return this.readLong();
                case 5:
                    return this.readFloat();
                case 6:
                    return this.readDouble();
                case 7:
                    return this.readByteArray();
                case 8:
                    return this.readString();
                case 9:
                    return this.readList();
                case 10:
                    return this.readCompound();
                case 11:
                    return this.readIntArray();
                case 12:
                    return this.readLongArray();
                default:
                    throw new Error(`Unsupported NBT tag type: ${type}`);
            }
        }
        parse() {
            try {
                try {
                    this.buffer = pako.ungzip(this.buffer);
                    this.offset = 0;
                } catch (e) {}
                const rootType = this.readByte();
                const rootName = this.readString();
                const data = this.readTag(rootType);
                return data;
            } catch (error) {
                throw new Error(`NBT parsing failed: ${error.message}`);
            }
        }
    }
    let resourcesZip = null;
    let modZips = [];
    let nbtData = null;
    const resourceInput = document.getElementById('resourceZip');
    const modInput = document.getElementById('modZip');
    const nbtInput = document.getElementById('nbtFile');
    const convertBtn = document.getElementById('convertBtn');
    const resourceZone = document.getElementById('resourceZone');
    const nbtZone = document.getElementById('nbtZone');
    resourceZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        resourceZone.classList.add('dragover');
    });
    resourceZone.addEventListener('dragleave', () => {
        resourceZone.classList.remove('dragover');
    });
    resourceZone.addEventListener('drop', (e) => {
        e.preventDefault();
        resourceZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) {
            resourceInput.files = e.dataTransfer.files;
            resourceInput.dispatchEvent(new Event('change'));
        }
    });
    nbtZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        nbtZone.classList.add('dragover');
    });
    nbtZone.addEventListener('dragleave', () => {
        nbtZone.classList.remove('dragover');
    });
    nbtZone.addEventListener('drop', (e) => {
        e.preventDefault();
        nbtZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) {
            nbtInput.files = e.dataTransfer.files;
            nbtInput.dispatchEvent(new Event('change'));
        }
    });

    function showToast(message, type = 'info', options = {}) {
        const {
            clearPrevious = false, duration = 3000
        } = options;
        const container = document.getElementById('toastContainer');
        if (clearPrevious) {
            container.innerHTML = '';
        }
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        const icon = type === 'success' ? '' : type === 'error' ? '' : '';
        toast.innerHTML = `
<div class="toast-icon">${icon}</div>
<div class="toast-message">${message}</div>
`;
        container.appendChild(toast);
        setTimeout(() => {
            toast.style.animation = 'slideInRight 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }

    function showProgress() {
        document.getElementById('progressOverlay').classList.add('show');
        updateProgress(0, 'Starting conversion...');
    }

    function hideProgress() {
        setTimeout(() => {
            document.getElementById('progressOverlay').classList.remove('show');
        }, 500);
    }

    function updateProgress(percentage, text) {
        document.getElementById('progressBarFill').style.width = percentage + '%';
        document.getElementById('progressPercentage').textContent = Math.round(percentage) + '%';
        document.getElementById('progressText').textContent = text;
    }
    async function extractMinecraftVersion(zip) {
        try {
            const versionFile = zip.file('version.json');
            if (versionFile) {
                const content = await versionFile.async('string');
                const versionData = JSON.parse(content);
                return versionData.id || versionData.name || 'Unknown';
            }
        } catch (e) {}
        return 'Unknown';
    }
    async function extractModInfo(zip, fileName) {
        try {
            const modsToml = zip.file('META-INF/mods.toml');
            if (modsToml) {
                const content = await modsToml.async('string');
                const modIdMatch = content.match(/modId\s*=\s*["']([^"']+)["']/);
                const versionMatch = content.match(/version\s*=\s*["']([^"']+)["']/);
                const mcVersionMatch = content.match(/loaderVersion\s*=\s*["']\[?([^\]"']+)\]?["']/);
                return {
                    modId: modIdMatch ? modIdMatch[1] : fileName.replace(/\.(jar|zip)$/, '').toLowerCase(),
                    version: versionMatch ? versionMatch[1] : 'Unknown',
                    mcVersions: mcVersionMatch ? mcVersionMatch[1] : 'Unknown'
                };
            }
            const fabricMod = zip.file('fabric.mod.json');
            if (fabricMod) {
                const content = await fabricMod.async('string');
                const modData = JSON.parse(content);
                return {
                    modId: modData.id || fileName.replace(/\.(jar|zip)$/, '').toLowerCase(),
                    version: modData.version || 'Unknown',
                    mcVersions: modData.depends?.minecraft || 'Unknown'
                };
            }
            const mcmodInfo = zip.file('mcmod.info');
            if (mcmodInfo) {
                const content = await mcmodInfo.async('string');
                const modData = JSON.parse(content);
                const firstMod = Array.isArray(modData) ? modData[0] : modData;
                return {
                    modId: firstMod.modid || fileName.replace(/\.(jar|zip)$/, '').toLowerCase(),
                    version: firstMod.version || 'Unknown',
                    mcVersions: firstMod.mcversion || 'Unknown'
                };
            }
        } catch (e) {
            console.error('Error extracting mod info:', e);
        }
        return {
            modId: fileName.replace(/\.(jar|zip)$/, '').toLowerCase(),
            version: 'Unknown',
            mcVersions: 'Unknown'
        };
    }
    resourceInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
            showToast('Loading Minecraft resources...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            resourcesZip = await JSZip.loadAsync(arrayBuffer);
            const version = await extractMinecraftVersion(resourcesZip);
            showToast('Resources loaded successfully!', 'success');
            const infoDiv = document.getElementById('resourceInfo');
            infoDiv.style.display = 'block';
            infoDiv.className = 'file-info';
            infoDiv.innerHTML = `
<div class="file-info-row">
<span class="file-info-label">Name:</span>
<span class="file-info-value">Minecraft</span>
</div>
<div class="file-info-row">
<span class="file-info-label">Version:</span>
<span class="file-info-value">${version}</span>
</div>
`;
            checkReady();
        } catch (error) {
            showToast('Error loading resources: ' + error.message, 'error');
        }
    });
    modInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        for (const file of files) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                const modInfo = await extractModInfo(zip, file.name);
                modZips.push({
                    name: file.name,
                    zip,
                    modId: modInfo.modId,
                    version: modInfo.version,
                    mcVersions: modInfo.mcVersions
                });
            } catch (error) {
                console.error('Error loading mod:', error);
            }
        }
        modInput.value = '';
        updateModList();
        if (modZips.length > 0) {
            showToast(`${modZips.length} mod(s) loaded`, 'success');
        }
    });
    window.removeMod = function(modId) {
        modZips = modZips.filter(m => m.modId !== modId);
        updateModList();
    };

    function updateModList() {
        const modList = document.getElementById('modList');
        modList.innerHTML = '';
        modZips.forEach(mod => {
            const modCard = document.createElement('div');
            modCard.className = 'mod-card';
            modCard.innerHTML = `
<div class="mod-card-header">
<div class="mod-card-title">${mod.modId}</div>
<button class="minecraft-button small" onclick="removeMod('${mod.modId}')" style="height: 25px; min-width: 80px;">
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
<div class="minecraft-button-name" style="font-size: 11px;">Remove</div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
</button>
</div>
<div class="mod-card-info">
<div><strong>Version:</strong> ${mod.version}</div>
<div><strong>MC Version:</strong> ${mod.mcVersions}</div>
</div>
`;
            modList.appendChild(modCard);
        });
    }
    async function extractModId(zip, fileName) {
        const info = await extractModInfo(zip, fileName);
        return info.modId;
    }
    nbtInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
            showToast('Parsing NBT file...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            const parser = new NBTParser(arrayBuffer);
            nbtData = parser.parse();
            // console.log('Parsed NBT data:', JSON.stringify(nbtData, null, 2));
            const blockCount = (nbtData.blocks || []).filter(b => {
                const state = (nbtData.palette || [])[b.state || 0];
                return state && state.Name !== "minecraft:air";
            }).length;
            showToast('NBT file parsed successfully!', 'success');
            const infoDiv = document.getElementById('nbtInfo');
            infoDiv.style.display = 'block';
            infoDiv.className = 'file-info';
            infoDiv.innerHTML = `
<div class="file-info-row">
<span class="file-info-label">Name:</span>
<span class="file-info-value">${file.name.replace('.nbt', '')}</span>
</div>
<div class="file-info-row">
<span class="file-info-label">Blocks:</span>
<span class="file-info-value">${blockCount}</span>
</div>
`;
            checkReady();
        } catch (error) {
            showToast('Error parsing NBT: ' + error.message, 'error');
        }
    });

    function checkReady() {
        convertBtn.disabled = !(resourcesZip && nbtData);
    }
    async function findFile(fileName, allZips) {
        for (const zipObj of allZips) {
            const file = zipObj.file(fileName);
            if (file) return file;
        }
        return null;
    }
    async function resolveBlockstate(blockName, properties, allZips) {
        const parts = blockName.split(':');
        const namespace = parts.length > 1 ? parts[0] : 'minecraft';
        const name = parts.length > 1 ? parts[1] : parts[0];
        const blockstatePath = `assets/${namespace}/blockstates/${name}.json`;
        let file = await findFile(blockstatePath, allZips);
        if (!file) return null;
        try {
            const content = await file.async('string');
            const blockstate = JSON.parse(content);
            const variants = evaluateBlockstate(blockstate, properties);
            if (!variants) return null;
            let usesEntityModel = false;
            if (variants.length > 0 && variants[0].model) {
                const testModel = await resolveModel(variants[0].model, allZips, 0, true);
                usesEntityModel = testModel === 'ENTITY_MODEL';
            }
            if (usesEntityModel) {
                try {
                    const fallbackUrl = `entity_models_blocks/blockstates/${name}.json`;
                    const response = await fetch(fallbackUrl, {
                        cache: 'no-store'
                    });
                    if (response.ok) {
                        const fallbackContent = await response.text();
                        const fallbackBlockstate = JSON.parse(fallbackContent);
                        const fallbackVariants = evaluateBlockstate(fallbackBlockstate, properties);
                        return fallbackVariants ? {
                            variants: fallbackVariants,
                            fromFallback: true
                        } : null;
                    }
                } catch (e) {}
            }
            return variants ? {
                variants,
                fromFallback: false
            } : null;
        } catch (error) {
            return null;
        }
    }

    function evaluateBlockstate(blockstate, properties) {
        if (blockstate.variants) {
            const fullKey = properties ?
                Object.entries(properties).sort().map(([k, v]) => `${k}=${v}`).join(',') : '';
            let variant = blockstate.variants[fullKey];
            if (!variant && properties) {
                const propsWithoutWaterlogged = {
                    ...properties
                };
                delete propsWithoutWaterlogged.waterlogged;
                const keyWithoutWaterlogged = Object.entries(propsWithoutWaterlogged)
                    .sort().map(([k, v]) => `${k}=${v}`).join(',');
                variant = blockstate.variants[keyWithoutWaterlogged];
            }
            if (!variant) {
                variant = blockstate.variants[''] || blockstate.variants['normal'];
            }
            if (!variant) {
                const firstKey = Object.keys(blockstate.variants)[0];
                variant = blockstate.variants[firstKey];
            }
            if (Array.isArray(variant)) {
                return [variant[0]];
            }
            return [variant];
        }
        if (blockstate.multipart) {
            const matchingParts = [];
            for (const part of blockstate.multipart) {
                if (!part.when) {
                    const apply = Array.isArray(part.apply) ? part.apply[0] : part.apply;
                    matchingParts.push(apply);
                    continue;
                }
                let matches = false;
                if (part.when.OR) {
                    matches = part.when.OR.some(condition => matchesCondition(condition, properties));
                } else {
                    matches = matchesCondition(part.when, properties);
                }
                if (matches) {
                    const apply = Array.isArray(part.apply) ? part.apply[0] : part.apply;
                    matchingParts.push(apply);
                }
            }
            return matchingParts.length > 0 ? matchingParts : null;
        }
        return null;
    }

    function matchesCondition(condition, properties) {
        if (!properties) return false;
        for (const [key, value] of Object.entries(condition)) {
            const propValue = properties[key];
            const acceptedValues = String(value).split('|');
            if (!acceptedValues.includes(String(propValue))) {
                return false;
            }
        }
        return true;
    }
    async function resolveModel(modelPath, allZips, depth = 0) {
        if (!modelPath || depth > 10) return null;
        if (!modelPath.includes(':')) {
            modelPath = 'minecraft:' + modelPath;
        }
        const parts = modelPath.split(':');
        const namespace = parts[0];
        let path = parts[1];
        if (!path.startsWith('block/') && !path.startsWith('item/')) {
            path = 'block/' + path;
        }
        const modelFilePath = `assets/${namespace}/models/${path}.json`;
        let file = await findFile(modelFilePath, allZips);
        if (!file) {
            try {
                const fallbackUrl = `entity_models_blocks/models/${path}.json`;
                const response = await fetch(fallbackUrl, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const content = await response.text();
                    const model = JSON.parse(content);
                    if (model.parent) {
                        const parentModel = await resolveModel(model.parent, allZips, depth + 1);
                        if (parentModel) {
                            return {
                                ...parentModel,
                                ...model,
                                textures: {
                                    ...(parentModel.textures || {}),
                                    ...(model.textures || {})
                                },
                                elements: model.elements || parentModel.elements,
                                display: model.display || parentModel.display
                            };
                        }
                    }
                    return model;
                }
            } catch (e) {}
            return null;
        }
        try {
            const content = await file.async('string');
            const model = JSON.parse(content);
            if (model.parent) {
                const parentModel = await resolveModel(model.parent, allZips, depth + 1);
                if (parentModel) {
                    const mergedModel = {
                        ...parentModel,
                        ...model,
                        textures: {
                            ...(parentModel.textures || {}),
                            ...(model.textures || {})
                        },
                        elements: model.elements || parentModel.elements,
                        display: model.display || parentModel.display
                    };
                    if (!mergedModel.elements || mergedModel.elements.length === 0) {
                        try {
                            const fallbackUrl = `entity_models_blocks/models/${path}.json`;
                            const response = await fetch(fallbackUrl, {
                                cache: 'no-store'
                            });
                            if (response.ok) {
                                const fallbackContent = await response.text();
                                const fallbackModel = JSON.parse(fallbackContent);
                                if (fallbackModel.elements && fallbackModel.elements.length > 0) {
                                    return {
                                        ...mergedModel,
                                        textures: {
                                            ...(mergedModel.textures || {}),
                                            ...(fallbackModel.textures || {})
                                        },
                                        elements: fallbackModel.elements
                                    };
                                }
                            }
                        } catch (e) {}
                    }
                    return mergedModel;
                }
            }
            if (!model.elements || model.elements.length === 0) {
                try {
                    const fallbackUrl = `entity_models_blocks/models/${path}.json`;
                    const response = await fetch(fallbackUrl, {
                        cache: 'no-store'
                    });
                    if (response.ok) {
                        const fallbackContent = await response.text();
                        const fallbackModel = JSON.parse(fallbackContent);
                        if (fallbackModel.elements && fallbackModel.elements.length > 0) {
                            return {
                                ...model,
                                textures: {
                                    ...(model.textures || {}),
                                    ...(fallbackModel.textures || {})
                                },
                                elements: fallbackModel.elements
                            };
                        }
                    }
                } catch (e) {}
            }
            return model;
        } catch (error) {
            return null;
        }
    }
    async function findTexture(texturePath, allZips) {
        if (!texturePath || texturePath.startsWith('#')) return null;
        const parts = texturePath.split(':');
        const namespace = parts.length > 1 ? parts[0] : 'minecraft';
        const path = parts.length > 1 ? parts[1] : parts[0];
        const searchPaths = [
            `assets/${namespace}/textures/block/${path}.png`,
            `assets/${namespace}/textures/${path}.png`,
            `assets/${namespace}/textures/entity/${path}.png`,
            `assets/${namespace}/textures/item/${path}.png`,
        ];
        for (const searchPath of searchPaths) {
            const file = await findFile(searchPath, allZips);
            if (file) return {
                file,
                path: searchPath
            };
        }
        const filename = path.split('/').pop();
        for (const zipObj of allZips) {
            const files = Object.keys(zipObj.files);
            for (const filepath of files) {
                if (filepath.includes('/textures/') && filepath.endsWith(`/${filename}.png`)) {
                    const file = zipObj.file(filepath);
                    if (file) return {
                        file,
                        path: filepath
                    };
                }
            }
        }
        try {
            const fallbackPaths = [
                `entity_models_blocks/textures/block/${path}.png`,
                `entity_models_blocks/textures/${path}.png`,
                `entity_models_blocks/textures/entity/${path}.png`,
                `entity_models_blocks/textures/entity/chest/${path}.png`,
            ];
            for (const fallbackUrl of fallbackPaths) {
                try {
                    const response = await fetch(fallbackUrl, {
                        cache: 'no-store'
                    });
                    if (response.ok) {
                        const blob = await response.blob();
                        return {
                            file: {
                                async: async (type) => {
                                    if (type === 'blob') return blob;
                                    return blob;
                                }
                            },
                            path: fallbackUrl
                        };
                    }
                } catch (e) {}
            }
        } catch (e) {}
        return null;
    }

    function resolveTextures(model, textureRefs = {}) {
        if (!model || !model.textures) return textureRefs;
        for (const [key, value] of Object.entries(model.textures)) {
            textureRefs[key] = value;
        }
        let changed = true;
        let iterations = 0;
        while (changed && iterations < 10) {
            changed = false;
            iterations++;
            for (const [key, value] of Object.entries(textureRefs)) {
                if (typeof value === 'string' && value.startsWith('#')) {
                    const refKey = value.substring(1);
                    if (textureRefs[refKey] && textureRefs[refKey] !== value) {
                        textureRefs[key] = textureRefs[refKey];
                        changed = true;
                    }
                }
            }
        }
        return textureRefs;
    }

function applyRotation(elements, xRot, yRot, uvlock = false) {
    if (!elements || elements.length === 0) return elements;

    const rotated = JSON.parse(JSON.stringify(elements));
        if (yRot) {
            const steps = Math.round(yRot / 90) % 4;
            for (const element of rotated) {
                const center = [8, 8, 8];
                for (let i = 0; i < steps; i++) {
                    let x = element.from[0] - center[0];
                    let z = element.from[2] - center[2];
                    element.from[0] = -z + center[0];
                    element.from[2] = x + center[2];
                    x = element.to[0] - center[0];
                    z = element.to[2] - center[2];
                    element.to[0] = -z + center[0];
                    element.to[2] = x + center[2];
                }
                if (element.from[0] > element.to[0]) {
                    [element.from[0], element.to[0]] = [element.to[0], element.from[0]];
                }
                if (element.from[2] > element.to[2]) {
                    [element.from[2], element.to[2]] = [element.to[2], element.from[2]];
                }
                if (element.faces) {
                    for (let i = 0; i < steps; i++) {
                        const oldFaces = {
                            ...element.faces
                        };
                        element.faces = {};
                        if (oldFaces.north) element.faces.east = oldFaces.north;
                        if (oldFaces.east) element.faces.south = oldFaces.east;
                        if (oldFaces.south) element.faces.west = oldFaces.south;
                        if (oldFaces.west) element.faces.north = oldFaces.west;
                        if (oldFaces.up) element.faces.up = oldFaces.up;
                        if (oldFaces.down) element.faces.down = oldFaces.down;
                    }
                    if (!uvlock) {
['up', 'down'].forEach(face => {
    if (element.faces[face] && element.faces[face].uv) {
        const uv = element.faces[face].uv;
        let rotatedUV = [...uv];

        const baseRotation = element.faces[face].rotation || 0;

        const totalSteps = ((steps + (baseRotation / 90)) % 4 + 4) % 4;

        for (let i = 0; i < totalSteps; i++) {
            const temp = [16 - rotatedUV[3], rotatedUV[0], 16 - rotatedUV[1], rotatedUV[2]];
            rotatedUV = temp;
        }

        element.faces[face].uv = rotatedUV;
    }
});
}
                }
            }
        }
        if (xRot === 180) {
            for (const element of rotated) {
                const oldFromY = element.from[1];
                const oldToY = element.to[1];
                element.from[1] = 16 - oldToY;
                element.to[1] = 16 - oldFromY;
                if (element.faces) {
                    const oldFaces = {
                        ...element.faces
                    };
                    element.faces = {};
                    if (oldFaces.up) element.faces.down = {
                        ...oldFaces.up
                    };
                    if (oldFaces.down) element.faces.up = {
                        ...oldFaces.down
                    };
                    ['north', 'south', 'east', 'west'].forEach(face => {
                        if (oldFaces[face]) {
                            element.faces[face] = {
                                ...oldFaces[face]
                            };
                            if (element.faces[face].uv) {
                                const uv = element.faces[face].uv;
                                element.faces[face].uv = [uv[0], 16 - uv[3], uv[2], 16 - uv[1]];
                            }
                        }
                    });
                }
            }
        }
        return rotated;
    }

    function showMissingBlocksModal(missingBlocks) {
        return new Promise((resolve, reject) => {
            missingBlocksResolver = resolve;
            const modalHTML = `
<div class="modal-overlay show" id="missingBlocksModal" style="z-index: 4000;">
<div class="missing-blocks-modal">
<div class="missing-blocks-header">
<div class="missing-blocks-title">Missing Block Models</div>
</div>

<div class="missing-blocks-body">
<p style="color: #cccccc; margin-bottom: 20px; font-size: 14px;">
The following blocks don't have model data. Please provide block models, blockstates, and textures for each:
</p>

<div class="missing-blocks-grid" id="missingBlocksGrid"></div>
</div>

<div class="missing-blocks-footer">
<p style="color: #cccccc; margin-bottom: 20px; font-size: 14px;">
* Most of these block models are missing because they have an entity model. You may need to recreate the block model and import.
</p>
<button class="minecraft-button cancel-button" onclick="cancelMissingBlocks()">
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
<div class="minecraft-button-name">Cancel</div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
</button>

<button class="minecraft-button success" onclick="continueMissingBlocks()">
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
<div class="minecraft-button-name">Continue Conversion</div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
</button>
</div>
</div>
</div>
`;
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            missingBlocksData = {};
            missingBlocks.forEach(block => {
                missingBlocksData[block.id] = {
                    models: [],
                    blockstate: null,
                    textures: [],
                    texturePath: [],
                    textureNamespace: block.namespace,
                    textureFilename: '',
                    skipped: false
                };
            });
            renderMissingBlocks(missingBlocks);
        });
    }
    async function scanJarDirectories(blockId) {
        const blockData = missingBlocksData[blockId];
        const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
        const folders = new Set();
        for (const zipObj of allZips) {
            const files = Object.keys(zipObj.files);
            for (const filepath of files) {
                if (filepath.includes(`assets/${blockData.textureNamespace}/textures/`)) {
                    const pathParts = filepath.split(`assets/${blockData.textureNamespace}/textures/`)[1];
                    if (pathParts) {
                        const folderParts = pathParts.split('/');
                        if (folderParts.length > 1) {
                            folders.add(folderParts[0]);
                        }
                    }
                }
            }
        }
        return Array.from(folders).sort();
    }
    async function getAvailableNamespaces() {
        const namespaces = new Set(['minecraft']);
        const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
        for (const zipObj of allZips) {
            const files = Object.keys(zipObj.files);
            for (const filepath of files) {
                if (filepath.startsWith('assets/')) {
                    const parts = filepath.split('/');
                    if (parts.length > 1) {
                        namespaces.add(parts[1]);
                    }
                }
            }
        }
        return Array.from(namespaces).sort();
    }
    async function renderMissingBlocks(blocks) {
        const grid = document.getElementById('missingBlocksGrid');
        grid.innerHTML = '';
        const availableNamespaces = await getAvailableNamespaces();
        for (const block of blocks) {
            const blockCard = document.createElement('div');
            blockCard.className = 'missing-block-card';
            blockCard.id = `block-${block.id.replace(/:/g, '-')}`;
            blockCard.dataset.blockId = block.id;
            const namespaceOptions = availableNamespaces.map(ns =>
                `<option value="${ns}" ${ns === block.namespace ? 'selected' : ''}>${ns}</option>`
            ).join('');
            blockCard.innerHTML = `
<div class="missing-block-header" onclick="toggleMissingBlock('${block.id}')">
<div>
<div class="missing-block-name">${block.name}</div>
<div class="missing-block-namespace">${block.namespace}</div>
</div>
<div style="display: flex; gap: 10px; align-items: center;">
<button class="minecraft-button small" onclick="event.stopPropagation(); skipBlock('${block.id}')" style="height: 25px; min-width: 80px;">
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
    <div class="minecraft-button-name" style="font-size: 11px;">Skip</div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
</button>
<img src="assets/wiki/buttons/dropdown_arrow.png" class="missing-block-arrow" style="width: 20px; height: 20px; image-rendering: pixelated; transition: transform 0.3s;">
</div>
</div>

<div class="missing-block-content" style="display: none; overflow: visible;">
<div class="missing-block-section" style="border-left: 4px solid #3453df;">
<div class="section-header">
<h3 style="color: #3453df; font-family: 'Minecraft Ten', sans-serif; font-size: 14px;">Block Models</h3>
<label class="upload-button">
    <input type="file" accept=".json" multiple onchange="handleBlockModelUpload('${block.id}', this.files)" style="display: none;">
    <span>Import Models</span>
</label>
</div>
<div id="models-${block.id.replace(/:/g, '-')}" class="file-list"></div>
</div>

<div class="missing-block-section" style="border-left: 4px solid #3a8b4a;">
<div class="section-header">
<h3 style="color: #3a8b4a; font-family: 'Minecraft Ten', sans-serif; font-size: 14px;">Blockstate</h3>
<label class="upload-button">
    <input type="file" accept=".json" onchange="handleBlockstateUpload('${block.id}', this.files[0])" style="display: none;">
    <span>Import Blockstate</span>
</label>
</div>
<div id="blockstate-${block.id.replace(/:/g, '-')}" class="file-list"></div>
</div>

<div class="missing-block-section" style="border-left: 4px solid #8b6a3a;">
<h3 style="color: #8b6a3a; font-family: 'Minecraft Ten', sans-serif; font-size: 14px; margin-bottom: 15px;">Textures</h3>

<label class="upload-button" style="margin-bottom: 15px; display: inline-block;">
<input type="file" accept=".png" multiple onchange="handleTextureUpload('${block.id}', this.files)" style="display: none;">
<span>Upload Textures</span>
</label>

<div id="textures-${block.id.replace(/:/g, '-')}" class="file-list" style="margin-bottom: 15px;"></div>

<div style="color: #cccccc; font-size: 12px; margin-bottom: 10px;">Or specify texture path:</div>

<div style="display: flex; align-items: center; gap: 5px; margin-bottom: 10px; flex-wrap: wrap;">
<span style="color: #a0a0a0; font-size: 12px;">assets/</span>
<select onchange="updateTextureNamespace('${block.id}', this.value)"
    style="background: #1a1a1a; border: 2px solid #0a0a0a; padding: 5px 10px; color: #e6e6e6; font-size: 12px;">
    ${namespaceOptions}
</select>
<span style="color: #a0a0a0; font-size: 12px;">/textures/</span>
<div id="path-${block.id.replace(/:/g, '-')}" style="display: flex; gap: 5px; flex-wrap: wrap; align-items: center;"></div>
</div>

<button class="minecraft-button small" onclick="addPathSegment('${block.id}')" style="margin-top: 10px;">
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
    <div class="minecraft-button-name" style="font-size: 11px;">+ Add Folder</div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
</button>
</div>
</div>
`;
            grid.appendChild(blockCard);
        }
    }

    function toggleMissingBlock(blockId) {
        const card = document.getElementById(`block-${blockId.replace(/:/g, '-')}`);
        const content = card.querySelector('.missing-block-content');
        const arrow = card.querySelector('.missing-block-arrow');
        const isExpanded = content.style.display !== 'none';
        if (isExpanded) {
            content.style.display = 'none';
            arrow.style.transform = 'rotate(0deg)';
            card.classList.remove('expanded');
        } else {
            content.style.display = 'block';
            arrow.style.transform = 'rotate(180deg)';
            card.classList.add('expanded');
        }
    }

    function handleBlockModelUpload(blockId, files) {
        Array.from(files).forEach(file => {
            missingBlocksData[blockId].models.push(file);
        });
        updateFileList(blockId, 'models');
    }

    function handleBlockstateUpload(blockId, file) {
        if (file) {
            missingBlocksData[blockId].blockstate = file;
            updateFileList(blockId, 'blockstate');
        }
    }

    function handleTextureUpload(blockId, files) {
        Array.from(files).forEach(file => {
            missingBlocksData[blockId].textures.push(file);
        });
        updateFileList(blockId, 'textures');
    }

    function updateTextureNamespace(blockId, namespace) {
        missingBlocksData[blockId].textureNamespace = namespace;
    }
    async function addPathSegment(blockId) {
        const folders = await scanJarDirectories(blockId);
        missingBlocksData[blockId].texturePath.push({
            type: 'select',
            value: '',
            options: folders
        });
        renderPathSegments(blockId);
    }

    function skipBlock(blockId) {
        missingBlocksData[blockId].skipped = true;
        const card = document.getElementById(`block-${blockId.replace(/:/g, '-')}`);
        card.style.opacity = '0.5';
        card.style.pointerEvents = 'none';
        showToast(`Skipped ${blockId}`, 'info', {
            duration: 2000
        });
    }
    async function updatePathSegment(blockId, index, value) {
        missingBlocksData[blockId].texturePath[index].value = value;
        if (value) {
            const subfolders = await scanSubfolders(blockId, index);
            if (subfolders.length > 0) {
                missingBlocksData[blockId].texturePath.push({
                    type: 'select',
                    value: '',
                    options: subfolders
                });
                renderPathSegments(blockId);
            }
        }
    }

    function removePathSegment(blockId, index) {
        missingBlocksData[blockId].texturePath.splice(index, 1);
        renderPathSegments(blockId);
    }
    async function scanSubfolders(blockId, upToIndex) {
        const blockData = missingBlocksData[blockId];
        const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
        const currentPath = blockData.texturePath
            .slice(0, upToIndex + 1)
            .map(seg => seg.value)
            .filter(Boolean)
            .join('/');
        const folders = new Set();
        const searchPath = `assets/${blockData.textureNamespace}/textures/${currentPath}/`;
        for (const zipObj of allZips) {
            const files = Object.keys(zipObj.files);
            for (const filepath of files) {
                if (filepath.startsWith(searchPath)) {
                    const remainder = filepath.substring(searchPath.length);
                    const parts = remainder.split('/');
                    if (parts.length > 1 && parts[0]) {
                        folders.add(parts[0]);
                    }
                }
            }
        }
        return Array.from(folders).sort();
    }

    function renderPathSegments(blockId) {
        const container = document.getElementById(`path-${blockId.replace(/:/g, '-')}`);
        const paths = missingBlocksData[blockId].texturePath;
        let html = '';
        paths.forEach((segment, index) => {
            if (segment.type === 'select') {
                const options = segment.options.map(opt =>
                    `<option value="${opt}" ${opt === segment.value ? 'selected' : ''}>${opt}</option>`
                ).join('');
                html += `
<span style="color: #a0a0a0; font-size: 12px;">/</span>
<select onchange="updatePathSegment('${blockId}', ${index}, this.value)"
    style="background: #1a1a1a; border: 2px solid #0a0a0a; padding: 5px 10px; color: #e6e6e6; font-size: 12px;">
    <option value="">Select folder...</option>
    ${options}
</select>
<button onclick="removePathSegment('${blockId}', ${index})"
    style="background: none; border: none; color: #8b3a3a; cursor: pointer; padding: 2px 5px; font-size: 14px;">
    
</button>
`;
            }
        });
        html += `
<span style="color: #a0a0a0; font-size: 12px;">/</span>
<input type="text" placeholder="filename.png"
value="${missingBlocksData[blockId].textureFilename || ''}"
onchange="updateTextureFilename('${blockId}', this.value)"
style="background: #1a1a1a; border: 2px solid #0a0a0a; padding: 5px 10px; color: #e6e6e6; font-size: 12px; width: 120px;">
`;
        container.innerHTML = html;
    }

    function updateTextureFilename(blockId, filename) {
        missingBlocksData[blockId].textureFilename = filename;
    }

    function updateFileList(blockId, type) {
        const container = document.getElementById(`${type}-${blockId.replace(/:/g, '-')}`);
        const files = type === 'blockstate' ?
            (missingBlocksData[blockId].blockstate ? [missingBlocksData[blockId].blockstate] : []) :
            missingBlocksData[blockId][type];
        container.innerHTML = files.map(file => `
<div style="background: #1a1a1a; padding: 5px 10px; margin-top: 5px; color: #e6e6e6; font-size: 12px;">
${file.name}
</div>
`).join('');
    }

    function cancelMissingBlocks() {
        document.getElementById('missingBlocksModal').remove();
        if (missingBlocksResolver) {
            missingBlocksResolver(null);
        }
        hideProgress();
    }

    function continueMissingBlocks() {
        const incompleteBlocks = [];
        for (const [blockId, data] of Object.entries(missingBlocksData)) {
            if (data.skipped) continue;
            const hasModels = data.models.length > 0;
            const hasBlockstate = data.blockstate !== null;
            const hasTextures = data.textures.length > 0 || data.texturePath.some(p => p.value) || data.textureFilename;
            if (!hasModels || !hasBlockstate || !hasTextures) {
                incompleteBlocks.push(blockId);
            }
        }
        if (incompleteBlocks.length > 0) {
            showToast(`Please complete or skip: ${incompleteBlocks.join(', ')}`, 'error', {
                duration: 5000
            });
            incompleteBlocks.forEach(blockId => {
                const card = document.getElementById(`block-${blockId.replace(/:/g, '-')}`);
                if (card) {
                    card.classList.add('incomplete');
                }
            });
            return;
        }
        document.getElementById('missingBlocksModal').remove();
        if (missingBlocksResolver) {
            missingBlocksResolver(missingBlocksData);
        }
    }
    const missingBlocksStyle = document.createElement('style');
    missingBlocksStyle.textContent = `
.missing-blocks-modal {
background: #2e2e2e;
border: 2px solid #1a1a1a;
max-width: 1200px;
width: 90%;
max-height: 90vh;
display: flex;
flex-direction: column;
box-shadow: inset 2px 2px 0 #3a3a3a, inset -2px -2px 0 #242424, 0 4px 20px rgba(0, 0, 0, 0.5);
}

.missing-blocks-header {
padding: 20px;
border-bottom: 2px solid #1a1a1a;
display: flex;
justify-content: space-between;
align-items: center;
background: #343231;
}

.missing-blocks-title {
color: #3453df;
font-size: 20px;
font-family: 'Minecraft Ten', sans-serif;
}

.missing-blocks-body {
padding: 25px;
overflow-y: auto;
flex: 1;
}

.missing-blocks-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 15px;
}

.missing-block-card {
background: #3a3a3a;
border: 2px solid #1a1a1a;
box-shadow: inset 1px 1px 0 #4a4a4a, inset -1px -1px 0 #2a2a2a;
}

.missing-block-card.expanded {
grid-column: 1 / -1;
}

.missing-block-header {
padding: 15px;
cursor: pointer;
display: flex;
justify-content: space-between;
align-items: center;
}

.missing-block-header:hover {
background: #424242;
}

.missing-block-name {
color: #3453df;
font-weight: 600;
font-size: 14px;
}

.missing-block-namespace {
color: #a0a0a0;
font-size: 12px;
}

.missing-block-content {
padding: 15px;
border-top: 2px solid #1a1a1a;
}

.missing-block-section {
background: #2a2a2a;
padding: 15px;
margin-bottom: 15px;
}

.section-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 10px;
}

.upload-button {
background: #48494a;
padding: 5px 15px;
color: white;
font-size: 12px;
cursor: pointer;
display: inline-block;
box-shadow: inset 1px 1px 0 #6c6d6d, inset -1px -1px 0 #5b5c5c;
border: 2px solid #1e1e1e;
}

.upload-button:hover {
background: #414242;
}

.file-list {
margin-top: 10px;
}

.missing-blocks-footer {
padding: 20px;
border-top: 2px solid #1a1a1a;
display: flex;
justify-content: flex-end;
gap: 15px;
}

.cancel-button .minecraft-button-section {
background: #8b3a3a !important;
box-shadow: inset 1px 1px 0 #b35f5f, inset -1px -1px 0 #a04e4e !important;
}

.cancel-button .minecraft-button-dark-strip {
background: #6b2525 !important;
}

.cancel-button:hover .minecraft-button-section {
background: #a04444 !important;
}

.cancel-button:hover .minecraft-button-dark-strip {
background: #7b3030 !important;
}

.missing-block-card.incomplete {
border: 2px solid #8b3a3a !important;
background: #3a3a3a;
}

.path-container {
display: flex;
align-items: center;
gap: 5px;
flex-wrap: wrap;
margin-bottom: 10px;
}

.path-container select,
.path-container input {
background: #1a1a1a;
border: 2px solid #0a0a0a;
padding: 5px 10px;
color: #e6e6e6;
font-size: 12px;
}

.path-container input[type="text"] {
width: 120px;
}
`;
    document.head.appendChild(missingBlocksStyle);
    async function convertToBoxUV(elements, usedTextures) {
        const textureAtlases = new Map();
        const uvRemapping = new Map();
        const textureImages = new Map();
        for (const [texturePath, textureResult] of usedTextures) {
            const blob = await textureResult.file.async('blob');
            const img = await createImageBitmap(blob);
            textureImages.set(texturePath, img);
        }
        const firstTexture = Array.from(textureImages.values())[0];
        const elementLayouts = [];
        for (let elemIndex = 0; elemIndex < elements.length; elemIndex++) {
            const element = elements[elemIndex];
            const dx = Math.abs(element.to[0] - element.from[0]);
            const dy = Math.abs(element.to[1] - element.from[1]);
            const dz = Math.abs(element.to[2] - element.from[2]);
            const layoutWidth = 2 * (dx + dz);
            const layoutHeight = dz + dy;
            elementLayouts.push({
                elemIndex,
                dx,
                dy,
                dz,
                layoutWidth,
                layoutHeight
            });
        }
        const packBlocks = elementLayouts.map(layout => ({
            w: layout.layoutWidth,
            h: layout.layoutHeight,
            data: layout
        }));
        packBlocks.sort((a, b) => (b.w * b.h) - (a.w * a.h));
        const packer = new GrowingPacker();
        packer.fit(packBlocks);
        let packedWidth = 0,
            packedHeight = 0;
        for (const block of packBlocks) {
            if (block.fit) {
                packedWidth = Math.max(packedWidth, block.fit.x + block.w);
                packedHeight = Math.max(packedHeight, block.fit.y + block.h);
            }
        }
        const atlasWidth = Math.pow(2, Math.ceil(Math.log2(packedWidth)));
        const atlasHeight = Math.pow(2, Math.ceil(Math.log2(packedHeight)));
        const canvas = document.createElement('canvas');
        canvas.width = atlasWidth;
        canvas.height = atlasHeight;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, atlasWidth, atlasHeight);
        for (const block of packBlocks) {
            if (!block.fit) continue;
            const layout = block.data;
            const element = elements[layout.elemIndex];
            const {
                dx,
                dy,
                dz,
                elemIndex
            } = layout;
            const baseX = block.fit.x;
            const baseY = block.fit.y;
            const boxUVLayout = {
                up: {
                    x: baseX + dz,
                    y: baseY,
                    w: dx,
                    h: dz
                },
                down: {
                    x: baseX + dz + dx,
                    y: baseY,
                    w: dx,
                    h: dz
                },
                west: {
                    x: baseX,
                    y: baseY + dz,
                    w: dz,
                    h: dy
                },
                north: {
                    x: baseX + dz,
                    y: baseY + dz,
                    w: dx,
                    h: dy
                },
                east: {
                    x: baseX + dz + dx,
                    y: baseY + dz,
                    w: dz,
                    h: dy
                },
                south: {
                    x: baseX + dz + dx + dz,
                    y: baseY + dz,
                    w: dx,
                    h: dy
                }
            };
            for (const [faceName, faceData] of Object.entries(element.faces || {})) {
                if (!faceData.uv || !boxUVLayout[faceName]) continue;
                const [u1, v1, u2, v2] = faceData.uv;
                let srcX = Math.min(u1, u2);
                let srcY = Math.min(v1, v2);
                let srcW = Math.abs(u2 - u1);
                let srcH = Math.abs(v2 - v1);
                const dest = boxUVLayout[faceName];
                if (faceData.rotation === 180) {
                    const tempCanvas1 = document.createElement('canvas');
                    tempCanvas1.width = srcW;
                    tempCanvas1.height = srcH;
                    const tempCtx1 = tempCanvas1.getContext('2d');
                    tempCtx1.imageSmoothingEnabled = false;
                    tempCtx1.drawImage(firstTexture, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);
                    const tempCanvas2 = document.createElement('canvas');
                    tempCanvas2.width = srcW;
                    tempCanvas2.height = srcH;
                    const tempCtx2 = tempCanvas2.getContext('2d');
                    tempCtx2.imageSmoothingEnabled = false;
                    tempCtx2.translate(srcW, srcH);
                    tempCtx2.rotate(Math.PI);
                    tempCtx2.drawImage(tempCanvas1, 0, 0);
                    ctx.drawImage(tempCanvas2, 0, 0, srcW, srcH, dest.x, dest.y, dest.w, dest.h);
                } else {
                    ctx.drawImage(
                        firstTexture,
                        srcX, srcY, srcW, srcH,
                        dest.x, dest.y, dest.w, dest.h
                    );
                }
                uvRemapping.set(`${elemIndex}_${faceName}`, {
                    newU1: dest.x,
                    newV1: dest.y,
                    newU2: dest.x + dest.w,
                    newV2: dest.y + dest.h
                });
            }
        }
        const atlasBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        textureAtlases.set('box_uv_atlas.png', {
            file: {
                async: async () => atlasBlob
            },
            path: 'textures/box_uv_atlas.png',
            width: atlasWidth,
            height: atlasHeight
        });
        const boxUVElements = elements.map((element, elemIndex) => {
            const newElement = {
                ...element,
                box_uv: true,
                faces: {}
            };
            for (const [faceName, faceData] of Object.entries(element.faces || {})) {
                const key = `${elemIndex}_${faceName}`;
                const remapping = uvRemapping.get(key);
                if (remapping) {
                    newElement.faces[faceName] = {
                        texture: 0,
                        uv: [remapping.newU1, remapping.newV1, remapping.newU2, remapping.newV2]
                    };
                } else {
                    newElement.faces[faceName] = {
                        ...faceData
                    };
                }
            }
            return newElement;
        });
        return {
            elements: boxUVElements,
            textures: textureAtlases,
            atlasInfo: {
                width: atlasWidth,
                height: atlasHeight,
                count: 1
            }
        };
    }
    async function createMeshAtlas(mesh, blocks, palette, allZips) {
        const { pos, size: meshSize, face, dim } = mesh;

        let atlasWidth, atlasHeight;
        switch(face) {
            case 'north':
            case 'south':
                atlasWidth = meshSize[0] * 16;
                atlasHeight = meshSize[1] * 16;
                break;
            case 'east':
            case 'west':
                atlasWidth = meshSize[2] * 16;
                atlasHeight = meshSize[1] * 16;
                break;
            case 'up':
            case 'down':
                atlasWidth = meshSize[0] * 16;
                atlasHeight = meshSize[2] * 16;
                break;
        }

        const canvas = document.createElement('canvas');
        canvas.width = atlasWidth;
        canvas.height = atlasHeight;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, atlasWidth, atlasHeight);

        const relevantBlocks = [];

        for (const block of blocks) {
            const blockPos = block.pos || [0, 0, 0];

            let inBounds = false;

            if (blockPos[dim] === pos[dim]) {
                const axes = [0, 1, 2].filter(i => i !== dim);
                const u = axes[0];
                const v = axes[1];

                if (blockPos[u] >= pos[u] && blockPos[u] < pos[u] + meshSize[u] &&
                    blockPos[v] >= pos[v] && blockPos[v] < pos[v] + meshSize[v]) {
                    inBounds = true;
                }
            }

            if (inBounds) {
                relevantBlocks.push(block);
            }
        }

        for (const block of relevantBlocks) {
            const blockPos = block.pos || [0, 0, 0];
            const stateIndex = block.state || 0;
            const blockState = palette[stateIndex];

            if (!blockState || blockState.Name === "minecraft:air") continue;

            const blockName = blockState.Name;
            const properties = blockState.Properties || {};

            const variantsResult = await resolveBlockstate(blockName, properties, allZips);
            if (!variantsResult) continue;

            const variants = variantsResult.variants;
            const variant = variants[0];
            if (!variant) continue;

            const modelData = await resolveModel(variant.model, allZips);
            if (!modelData) continue;

            let textures = resolveTextures(modelData);

            const mcElement = modelData.elements?.[0];
            if (!mcElement) continue;

            const faceData = mcElement.faces?.[face];
            if (!faceData) continue;

            let texturePath = faceData.texture;
            if (texturePath?.startsWith('#')) {
                let key = texturePath.slice(1);
                for (let i = 0; i < 10 && textures[key]?.startsWith('#'); i++) {
                    key = textures[key].slice(1);
                }
                texturePath = textures[key];
            }

            if (!texturePath || texturePath.startsWith('#')) continue;

            const tex = await findTexture(texturePath, allZips);
            if (!tex) continue;

            const blob = await tex.file.async('blob');
            const img = await createImageBitmap(blob);

            let atlasX, atlasY;

            switch(face) {
                case 'north':
                case 'south':
                    atlasX = (blockPos[0] - pos[0]) * 16;
                    atlasY = (blockPos[1] - pos[1]) * 16;
                    break;
                case 'east':
                case 'west':
                    atlasX = (blockPos[2] - pos[2]) * 16;
                    atlasY = (blockPos[1] - pos[1]) * 16;
                    break;
                case 'up':
                case 'down':
                    atlasX = (blockPos[0] - pos[0]) * 16;
                    atlasY = (blockPos[2] - pos[2]) * 16;
                    break;
            }

            ctx.drawImage(img, atlasX, atlasY, 16, 16);
        }

        const atlasBlob = await new Promise(resolve => {
            canvas.toBlob(blob => resolve(blob), 'image/png');
        });

        return atlasBlob;
    }

    async function createOptimizedMesh(blocks, palette, size, allZips) {
        const blockComplexity = new Map();

        for (const block of blocks) {
            const stateIndex = block.state || 0;
            const blockState = palette[stateIndex];
            if (!blockState || blockState.Name === "minecraft:air") continue;

            const blockName = blockState.Name;
            if (blockComplexity.has(blockName)) continue;

            const properties = blockState.Properties || {};
            const variantsResult = await resolveBlockstate(blockName, properties, allZips);
            if (!variantsResult) {
                blockComplexity.set(blockName, false);
                continue;
            }

            const variants = variantsResult.variants;
            const variant = variants[0];
            if (!variant) {
                blockComplexity.set(blockName, false);
                continue;
            }

            const modelData = await resolveModel(variant.model, allZips);
            if (!modelData || !modelData.elements || modelData.elements.length !== 1) {
                blockComplexity.set(blockName, false);
                continue;
            }

            const element = modelData.elements[0];
            const from = element.from || [0, 0, 0];
            const to = element.to || [16, 16, 16];

            const isFullCube = from[0] === 0 && from[1] === 0 && from[2] === 0 &&
                               to[0] === 16 && to[1] === 16 && to[2] === 16;

            blockComplexity.set(blockName, isFullCube);
        }

        const grid = new Array(size[0]);
        for (let x = 0; x < size[0]; x++) {
            grid[x] = new Array(size[1]);
            for (let y = 0; y < size[1]; y++) {
                grid[x][y] = new Array(size[2]).fill(null);
            }
        }

        for (const block of blocks) {
            const pos = block.pos || [0, 0, 0];
            const stateIndex = block.state || 0;
            const blockState = palette[stateIndex];
            if (!blockState || blockState.Name === "minecraft:air") continue;

            const blockName = blockState.Name;
            const isSimple = blockComplexity.get(blockName) || false;

            grid[pos[0]][pos[1]][pos[2]] = {
                name: blockName,
                properties: blockState.Properties || {},
                state: blockState,
                isSimpleCube: isSimple
            };
        }

        const processed = new Array(size[0]);
        for (let x = 0; x < size[0]; x++) {
            processed[x] = new Array(size[1]);
            for (let y = 0; y < size[1]; y++) {
                processed[x][y] = new Array(size[2]).fill(false);
            }
        }

        const meshes = [];

        const axes = [
            { dim: 0, u: 1, v: 2, normal: [1, 0, 0], face: 'east', oppFace: 'west' },   // +X
            { dim: 0, u: 1, v: 2, normal: [-1, 0, 0], face: 'west', oppFace: 'east' },  // -X
            { dim: 1, u: 0, v: 2, normal: [0, 1, 0], face: 'up', oppFace: 'down' },     // +Y
            { dim: 1, u: 0, v: 2, normal: [0, -1, 0], face: 'down', oppFace: 'up' },    // -Y
            { dim: 2, u: 0, v: 1, normal: [0, 0, 1], face: 'south', oppFace: 'north' }, // +Z
            { dim: 2, u: 0, v: 1, normal: [0, 0, -1], face: 'north', oppFace: 'south' } // -Z
        ];

        for (const axis of axes) {
            const { dim, u, v, normal, face, oppFace } = axis;
            const positive = normal[dim] > 0;

            for (let d = 0; d < size[dim]; d++) {
                const mask = new Array(size[u]);
                for (let i = 0; i < size[u]; i++) {
                    mask[i] = new Array(size[v]).fill(null);
                }

                for (let i = 0; i < size[u]; i++) {
                    for (let j = 0; j < size[v]; j++) {
                        const pos = [0, 0, 0];
                        pos[dim] = d;
                        pos[u] = i;
                        pos[v] = j;

                        const [x, y, z] = pos;
                        const block = grid[x]?.[y]?.[z];

                        if (!block || !block.isSimpleCube) continue;

                        const neighborPos = [x, y, z];
                        neighborPos[dim] += positive ? 1 : -1;

                        const [nx, ny, nz] = neighborPos;
                        const neighbor = grid[nx]?.[ny]?.[nz];

                        if (!neighbor || (nx < 0 || ny < 0 || nz < 0 || nx >= size[0] || ny >= size[1] || nz >= size[2])) {
                            mask[i][j] = {
                                blockName: block.name,
                                properties: block.properties,
                                x, y, z
                            };
                        }
                    }
                }

                for (let i = 0; i < size[u]; i++) {
                    for (let j = 0; j < size[v]; j++) {
                        if (!mask[i][j]) continue;

                        const blockData = mask[i][j];

                        let width = 1;
                        while (i + width < size[u] &&
                               mask[i + width][j] &&
                               mask[i + width][j].blockName === blockData.blockName &&
                               JSON.stringify(mask[i + width][j].properties) === JSON.stringify(blockData.properties)) {
                            width++;
                        }

                        let height = 1;
                        let done = false;
                        while (j + height < size[v] && !done) {
                            for (let k = 0; k < width; k++) {
                                if (!mask[i + k][j + height] ||
                                    mask[i + k][j + height].blockName !== blockData.blockName ||
                                    JSON.stringify(mask[i + k][j + height].properties) !== JSON.stringify(blockData.properties)) {
                                    done = true;
                                    break;
                                }
                            }
                            if (!done) height++;
                        }

                        const quadPos = [0, 0, 0];
                        quadPos[dim] = d;
                        quadPos[u] = i;
                        quadPos[v] = j;

                        const quadSize = [1, 1, 1];
                        quadSize[u] = width;
                        quadSize[v] = height;

                        meshes.push({
                            pos: quadPos,
                            size: quadSize,
                            face: face,
                            blockName: blockData.blockName,
                            properties: blockData.properties,
                            normal: normal,
                            dim: dim
                        });

                        for (let di = 0; di < width; di++) {
                            for (let dj = 0; dj < height; dj++) {
                                mask[i + di][j + dj] = null;
                            }
                        }
                    }
                }
            }
        }

        return { meshes, blockComplexity };
    }

    async function convertStructureOptimized(blocks, palette, size, allZips) {
        const meshData = await createOptimizedMesh(blocks, palette, size, allZips);
        const meshes = meshData.meshes;
        const blockComplexity = meshData.blockComplexity;

        const blockbenchElements = [];
        const blockGroups = {};
        const blockTypeCounts = {};
        const usedTexturesLocal = new Map();
        const blockTypeToTextureLocal = new Map();
        const atlasTextures = [];

        updateProgress(35, `Optimizing ${meshes.length} merged faces...`);
        await new Promise(resolve => setTimeout(resolve, 50));

        let processedMeshes = 0;
        let atlasIndex = 0;

        for (const mesh of meshes) {
            try {
                const { pos, size: meshSize, face, blockName, properties, dim } = mesh;

                const atlasBlob = await createMeshAtlas(mesh, blocks, palette, allZips);
                const atlasPath = `atlas_${atlasIndex}`;
                atlasTextures.push({ path: atlasPath, blob: atlasBlob });
                atlasIndex++;

                usedTexturesLocal.set(atlasPath, { file: { async: async () => atlasBlob }, blob: atlasBlob });

                const simpleName = blockName.replace(/^[^:]+:/, '');

                if (!blockTypeToTextureLocal.has(simpleName)) {
                    blockTypeToTextureLocal.set(simpleName, atlasPath);
                }

                if (!blockGroups[simpleName]) {
                    blockGroups[simpleName] = {
                        name: simpleName + '_optimized',
                        origin: [8, 8, 8],
                        color: 0,
                        children: []
                    };
                }

                blockTypeCounts[simpleName] ??= 0;
                blockTypeCounts[simpleName]++;
                const blockNumber = blockTypeCounts[simpleName];

                const from = [pos[0] * 16, pos[1] * 16, pos[2] * 16];
                const to = [
                    (pos[0] + meshSize[0]) * 16,
                    (pos[1] + meshSize[1]) * 16,
                    (pos[2] + meshSize[2]) * 16
                ];

                const bbFaces = {};

                let atlasWidth, atlasHeight;
                switch(face) {
                    case 'north':
                    case 'south':
                        atlasWidth = meshSize[0] * 16;
                        atlasHeight = meshSize[1] * 16;
                        break;
                    case 'east':
                    case 'west':
                        atlasWidth = meshSize[2] * 16;
                        atlasHeight = meshSize[1] * 16;
                        break;
                    case 'up':
                    case 'down':
                        atlasWidth = meshSize[0] * 16;
                        atlasHeight = meshSize[2] * 16;
                        break;
                }

                bbFaces[face] = {
                    texture: atlasPath,
                    uv: [0, 0, atlasWidth, atlasHeight]
                };

                blockbenchElements.push({
                    name: `${simpleName}_merged_${blockNumber}`,
                    from: from,
                    to: to,
                    origin: [pos[0] * 16 + 8, pos[1] * 16 + 8, pos[2] * 16 + 8],
                    uuid: generateUUID(),
                    faces: bbFaces
                });

                blockGroups[simpleName].children.push(blockbenchElements.length - 1);

            } catch (error) {
                console.error('Error processing mesh:', mesh, error);
                continue;
            }

            processedMeshes++;
            if (processedMeshes % 50 === 0) {
                updateProgress(35 + (processedMeshes / meshes.length) * 25, `Optimizing: ${processedMeshes}/${meshes.length}`);
                await new Promise(r => setTimeout(r, 0));
            }
        }

        updateProgress(60, 'Processing complex blocks...');
        await new Promise(resolve => setTimeout(resolve, 50));

        let processedComplex = 0;
        const complexBlocks = blocks.filter(block => {
            const stateIndex = block.state || 0;
            const blockState = palette[stateIndex];
            if (!blockState || blockState.Name === "minecraft:air") return false;
            return !blockComplexity.get(blockState.Name);
        });

        for (const block of complexBlocks) {
            try {
                const pos = block.pos || [0, 0, 0];
                const stateIndex = block.state || 0;
                const blockState = palette[stateIndex];
                if (!blockState || blockState.Name === "minecraft:air") continue;

                const blockName = blockState.Name;
                const properties = blockState.Properties || {};

                const variantsResult = await resolveBlockstate(blockName, properties, allZips);
                if (!variantsResult) continue;

                const variants = variantsResult.variants;
                const fromFallback = variantsResult.fromFallback;
                const simpleName = blockName.replace(/^[^:]+:/, '');

                if (!blockGroups[simpleName]) {
                    blockGroups[simpleName] = {
                        name: simpleName + '_complex',
                        origin: [8, 8, 8],
                        color: 0,
                        children: []
                    };
                }

                blockTypeCounts[simpleName] ??= 0;
                blockTypeCounts[simpleName]++;
                const blockNumber = blockTypeCounts[simpleName];

                for (let partIndex = 0; partIndex < variants.length; partIndex++) {
                    const variant = variants[partIndex];
                    const modelData = variant ? await resolveModel(variant.model, allZips) : null;

                    let rotation = { x: variant?.x || 0, y: variant?.y || 0 };
                    const uvlock = variant?.uvlock || false;

                    if (fromFallback && properties.facing && rotation.y === 0) {
                        const map = { north: 0, south: 180, west: 270, east: 90 };
                        rotation.y = map[properties.facing] ?? 0;
                    }
                    if (fromFallback && properties.axis && rotation.x === 0) {
                        const map = {
                            y: { x: 0, y: 0 },
                            z: { x: 90, y: 0 },
                            x: { x: 90, y: 90 }
                        };
                        Object.assign(rotation, map[properties.axis] ?? {});
                    }

                    let textures = modelData ? resolveTextures(modelData) : {};
                    let elements = modelData?.elements ?? [{
                        from: [0, 0, 0],
                        to: [16, 16, 16],
                        faces: {
                            north: {}, east: {}, south: {},
                            west: {}, up: {}, down: {}
                        }
                    }];

                    if (rotation.x || rotation.y) {
                        elements = applyRotation(elements, rotation.x, rotation.y);
                    }

                    if (!blockTypeToTextureLocal.has(simpleName)) {
                        for (const mcElement of elements) {
                            let found = false;
                            for (const faceName of ['north', 'east', 'south', 'west', 'up', 'down']) {
                                const faceData = mcElement.faces?.[faceName];
                                if (!faceData) continue;
                                let texturePath = faceData.texture;
                                if (texturePath?.startsWith('#')) {
                                    let key = texturePath.slice(1);
                                    for (let i = 0; i < 10 && textures[key]?.startsWith('#'); i++) {
                                        key = textures[key].slice(1);
                                    }
                                    texturePath = textures[key];
                                }
                                if (texturePath && !texturePath.startsWith('#')) {
                                    blockTypeToTextureLocal.set(simpleName, texturePath);
                                    found = true;
                                    break;
                                }
                            }
                            if (found) break;
                        }
                    }

                    for (const mcElement of elements) {
                        const from = mcElement.from || [0, 0, 0];
                        const to = mcElement.to || [16, 16, 16];
                        const bbFrom = [
                            pos[0] * 16 + from[0],
                            pos[1] * 16 + from[1],
                            pos[2] * 16 + from[2]
                        ];
                        const bbTo = [
                            pos[0] * 16 + to[0],
                            pos[1] * 16 + to[1],
                            pos[2] * 16 + to[2]
                        ];

                        const bbFaces = {};
                        for (const faceName of ['north', 'east', 'south', 'west', 'up', 'down']) {
                            const faceData = mcElement.faces?.[faceName];
                            if (!faceData) continue;

                            let texturePath = faceData.texture;
                            if (texturePath?.startsWith('#')) {
                                let key = texturePath.slice(1);
                                for (let i = 0; i < 10 && textures[key]?.startsWith('#'); i++) {
                                    key = textures[key].slice(1);
                                }
                                texturePath = textures[key];
                            }

                            let faceTexturePath = null;
                            if (texturePath && !texturePath.startsWith('#')) {
                                const tex = await findTexture(texturePath, allZips);
                                if (tex) {
                                    usedTexturesLocal.set(texturePath, tex);
                                    faceTexturePath = texturePath;
                                }
                            }

                            const face = { texture: faceTexturePath || 0 };
                            if (faceData.uv) {
                                face.uv = faceData.uv;
                            } else {
                                switch (faceName) {
                                    case 'north':
                                    case 'south':
                                        face.uv = [from[0], 16 - to[1], to[0], 16 - from[1]];
                                        break;
                                    case 'east':
                                    case 'west':
                                        face.uv = [from[2], 16 - to[1], to[2], 16 - from[1]];
                                        break;
                                    case 'up':
                                    case 'down':
                                        face.uv = [from[0], from[2], to[0], to[2]];
                                        break;
                                }
                            }
                            if (faceData.rotation !== undefined) face.rotation = faceData.rotation;
                            if (faceData.tintindex !== undefined) face.tintindex = faceData.tintindex;
                            if (faceData.cullface !== undefined) face.cullface = faceData.cullface;

                            bbFaces[faceName] = face;
                        }

                        blockbenchElements.push({
                            name: `${simpleName}_${blockNumber}`,
                            from: bbFrom,
                            to: bbTo,
                            origin: [pos[0] * 16 + 8, pos[1] * 16 + 8, pos[2] * 16 + 8],
                            uuid: generateUUID(),
                            faces: bbFaces
                        });

                        blockGroups[simpleName].children.push(blockbenchElements.length - 1);
                    }
                }

            } catch (error) {
                console.error('Error processing complex block:', block, error);
                continue;
            }

            processedComplex++;
            if (processedComplex % 10 === 0) {
                updateProgress(60 + (processedComplex / complexBlocks.length) * 15, `Complex blocks: ${processedComplex}/${complexBlocks.length}`);
                await new Promise(r => setTimeout(r, 0));
            }
        }

        return {
            elements: blockbenchElements,
            groups: Object.values(blockGroups),
            usedTextures: usedTexturesLocal,
            blockTypeToTexture: blockTypeToTextureLocal,
            atlasTextures: atlasTextures
        };
    }

    async function convertStructure() {
        try {
            showProgress();
            await new Promise(resolve => setTimeout(resolve, 100));
            updateProgress(10, 'Initializing...');
            await new Promise(resolve => setTimeout(resolve, 100));
            const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
            const palette = nbtData.palette || [];
            const blocks = nbtData.blocks || [];
            const size = nbtData.size || [16, 16, 16];
            const missingBlocks = [];
            const missingBlocksSet = new Set();
            updateProgress(20, 'Checking for missing blocks...');
            await new Promise(resolve => setTimeout(resolve, 100));
            for (const block of blocks) {
                const stateIndex = block.state || 0;
                const blockState = palette[stateIndex];
                if (!blockState || blockState.Name === "minecraft:air") continue;
                const blockName = blockState.Name;
                const properties = blockState.Properties || {};
                const variantsResult = await resolveBlockstate(blockName, properties, allZips);
                if (!variantsResult) {
                    if (!missingBlocksSet.has(blockName)) {
                        missingBlocksSet.add(blockName);
                        const parts = blockName.split(':');
                        missingBlocks.push({
                            id: blockName,
                            name: parts.length > 1 ? parts[1] : parts[0],
                            namespace: parts.length > 1 ? parts[0] : 'minecraft'
                        });
                    }
                    continue;
                }
                const variants = variantsResult.variants;
                let hasModel = false;
                for (const variant of variants) {
                    if (!variant?.model) continue;
                    const modelData = await resolveModel(variant.model, allZips);
                    if (modelData?.elements?.length > 0) {
                        hasModel = true;
                        break;
                    }
                }
                if (!hasModel && !missingBlocksSet.has(blockName)) {
                    missingBlocksSet.add(blockName);
                    const parts = blockName.split(':');
                    missingBlocks.push({
                        id: blockName,
                        name: parts.length > 1 ? parts[1] : parts[0],
                        namespace: parts.length > 1 ? parts[0] : 'minecraft'
                    });
                }
            }
            if (missingBlocks.length > 0) {
                updateProgress(30, `Found ${missingBlocks.length} missing blocks. Waiting for user input...`);
                const userData = await showMissingBlocksModal(missingBlocks);
                if (!userData) {
                    hideProgress();
                    showToast('Conversion cancelled', 'info');
                    return;
                }
                const tempZip = new JSZip();
                for (const [blockId, data] of Object.entries(userData)) {
                    if (data.skipped) continue;
                    const parts = blockId.split(':');
                    const namespace = parts[0];
                    const name = parts[1];
                    for (const modelFile of data.models) {
                        const content = await modelFile.text();
                        tempZip.file(`assets/${namespace}/models/block/${modelFile.name}`, content);
                    }
                    if (data.blockstate) {
                        const content = await data.blockstate.text();
                        tempZip.file(`assets/${namespace}/blockstates/${name}.json`, content);
                    }
                    for (const textureFile of data.textures) {
                        const blob = await textureFile.arrayBuffer();
                        tempZip.file(`assets/${namespace}/textures/block/${textureFile.name}`, blob);
                    }
                    if (data.textureFilename && data.texturePath.length > 0) {
                        const pathParts = data.texturePath.map(p => p.value).filter(Boolean);
                        const fullPath = pathParts.join('/');
                        const searchPath = `assets/${data.textureNamespace}/textures/${fullPath}/${data.textureFilename}`;
                        for (const zipObj of [resourcesZip, ...modZips.map(m => m.zip)]) {
                            const file = zipObj.file(searchPath);
                            if (file) {
                                const blob = await file.async('arraybuffer');
                                tempZip.file(`assets/${namespace}/textures/block/${data.textureFilename}`, blob);
                                break;
                            }
                        }
                    }
                }
                allZips.unshift(tempZip);
                showToast('Continuing with provided data...', 'info');
            }
            updateProgress(30, 'Analyzing structure...');
            await new Promise(resolve => setTimeout(resolve, 100));

            const useGreedyMesh = document.getElementById('greedyMeshCheckbox')?.checked || false;

            const blockbenchModel = {
                meta: {
                    format_version: "4.5",
                    model_format: "free",
                    box_uv: false
                },
                name: "minecraft_structure",
                geometry_name: "",
                visible_box: [1, 1, 0],
                variable_placeholders: "",
                variable_placeholder_buttons: [],
                resolution: {
                    width: 16,
                    height: 16
                },
                elements: [],
                outliner: [],
                groups: [],
                textures: []
            };

            usedTextures = new Map();
            let blockTypeToTexture = new Map();
            let atlasTextures = [];

            if (useGreedyMesh) {
                showToast('Using mesh optimization...', 'info', { duration: 2000 });
                const optimizedResult = await convertStructureOptimized(blocks, palette, size, allZips);
                blockbenchModel.elements = optimizedResult.elements;
                blockbenchModel.groups = optimizedResult.groups;
                usedTextures = optimizedResult.usedTextures;
                blockTypeToTexture = optimizedResult.blockTypeToTexture;
                atlasTextures = optimizedResult.atlasTextures || [];
            } else {
                const blockGroups = {};
                const blockTypeCounts = {};
                let processedBlocks = 0;
                updateProgress(35, `Processing ${blocks.length} blocks...`);
                await new Promise(resolve => setTimeout(resolve, 50));
                for (const block of blocks) {
                try {
                    const pos = block.pos || [0, 0, 0];
                    const stateIndex = block.state || 0;
                    const blockState = palette[stateIndex];
                    if (!blockState || blockState.Name === "minecraft:air") continue;
                    const blockName = blockState.Name;
                    const properties = blockState.Properties || {};
                    const variantsResult = await resolveBlockstate(blockName, properties, allZips);
                    if (!variantsResult) continue;
                    const variants = variantsResult.variants;
                    const fromFallback = variantsResult.fromFallback;
                    const simpleName = blockName.replace(/^[^:]+:/, '');
                    if (!blockGroups[simpleName]) {
                        blockGroups[simpleName] = {
                            name: simpleName,
                            origin: [8, 8, 8],
                            color: 0,
                            children: []
                        };
                    }
                    blockTypeCounts[simpleName] ??= 0;
                    blockTypeCounts[simpleName]++;
                    const blockNumber = blockTypeCounts[simpleName];
for (let partIndex = 0; partIndex < variants.length; partIndex++) {
    const variant = variants[partIndex];
    const modelData = variant ? await resolveModel(variant.model, allZips) : null;

    let rotation = { x: variant?.x || 0, y: variant?.y || 0 };
    const uvlock = variant?.uvlock || false;
                        if (fromFallback && properties.facing && rotation.y === 0) {
                            const map = {
                                north: 0,
                                south: 180,
                                west: 270,
                                east: 90
                            };
                            rotation.y = map[properties.facing] ?? 0;
                        }
                        if (fromFallback && properties.axis && rotation.x === 0) {
                            const map = {
                                y: {
                                    x: 0,
                                    y: 0
                                },
                                z: {
                                    x: 90,
                                    y: 0
                                },
                                x: {
                                    x: 90,
                                    y: 90
                                }
                            };
                            Object.assign(rotation, map[properties.axis] ?? {});
                        }
                        let textures = modelData ? resolveTextures(modelData) : {};
                        let elements = modelData?.elements ?? [{
                            from: [0, 0, 0],
                            to: [16, 16, 16],
                            faces: {
                                north: {},
                                east: {},
                                south: {},
                                west: {},
                                up: {},
                                down: {}
                            }
                        }];
                        if (rotation.x || rotation.y) {
                            elements = applyRotation(elements, rotation.x, rotation.y);
                        }
                        if (!blockTypeToTexture.has(simpleName)) {
                            for (const mcElement of elements) {
                                let found = false;
                                for (const faceName of ['north', 'east', 'south', 'west', 'up', 'down']) {
                                    const faceData = mcElement.faces?.[faceName];
                                    if (!faceData) continue;
                                    let texturePath = faceData.texture;
                                    if (texturePath?.startsWith('#')) {
                                        let key = texturePath.slice(1);
                                        for (let i = 0; i < 10 && textures[key]?.startsWith('#'); i++) {
                                            key = textures[key].slice(1);
                                        }
                                        texturePath = textures[key];
                                    }
                                    if (texturePath && !texturePath.startsWith('#')) {
                                        blockTypeToTexture.set(simpleName, texturePath);
                                        found = true;
                                        break;
                                    }
                                }
                                if (found) break;
                            }
                        }
                        for (const mcElement of elements) {
                            const from = mcElement.from || [0, 0, 0];
                            const to = mcElement.to || [16, 16, 16];
                            const bbFrom = [
                                pos[0] * 16 + from[0],
                                pos[1] * 16 + from[1],
                                pos[2] * 16 + from[2]
                            ];
                            const bbTo = [
                                pos[0] * 16 + to[0],
                                pos[1] * 16 + to[1],
                                pos[2] * 16 + to[2]
                            ];
                            const bbFaces = {};
                            for (const faceName of ['north', 'east', 'south', 'west', 'up', 'down']) {
                                const faceData = mcElement.faces?.[faceName];
                                if (!faceData) continue;
                                let texturePath = faceData.texture;
                                if (texturePath?.startsWith('#')) {
                                    let key = texturePath.slice(1);
                                    for (let i = 0; i < 10 && textures[key]?.startsWith('#'); i++) {
                                        key = textures[key].slice(1);
                                    }
                                    texturePath = textures[key];
                                }
                                let faceTexturePath = null;
                                if (texturePath && !texturePath.startsWith('#')) {
                                    const tex = await findTexture(texturePath, allZips);
                                    if (tex) {
                                        usedTextures.set(texturePath, tex);
                                        faceTexturePath = texturePath;
                                    }
                                }
                                const face = {
                                    texture: faceTexturePath || 0
                                };
                                if (faceData.uv) {
                                    face.uv = faceData.uv;
                                } else {
                                    switch (faceName) {
                                        case 'north':
                                        case 'south':
                                            face.uv = [from[0], 16 - to[1], to[0], 16 - from[1]];
                                            break;
                                        case 'east':
                                        case 'west':
                                            face.uv = [from[2], 16 - to[1], to[2], 16 - from[1]];
                                            break;
                                        case 'up':
                                        case 'down':
                                            face.uv = [from[0], from[2], to[0], to[2]];
                                            break;
                                    }
                                }
                                if (faceData.rotation !== undefined) face.rotation = faceData.rotation;
                                if (faceData.tintindex !== undefined) face.tintindex = faceData.tintindex;
                                if (faceData.cullface !== undefined) face.cullface = faceData.cullface;
                                bbFaces[faceName] = face;
                            }
                            blockbenchModel.elements.push({
                                name: `${simpleName}_${blockNumber}`,
                                from: bbFrom,
                                to: bbTo,
                                origin: [pos[0] * 16 + 8, pos[1] * 16 + 8, pos[2] * 16 + 8],
                                uuid: generateUUID(),
                                faces: bbFaces
                            });
                            blockGroups[simpleName].children.push(blockbenchModel.elements.length - 1);
                        }
                    }
                } catch (error) {
                    console.error('Error processing block:', block, error);
                    continue;
                }
                processedBlocks++;
                if (processedBlocks % 10 === 0) {
                    updateProgress(35 + (processedBlocks / blocks.length) * 40, `Processing: ${processedBlocks}/${blocks.length}`);
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            blockbenchModel.groups = Object.values(blockGroups);
            }

            blockbenchModel.outliner = blockbenchModel.groups.map((_, i) => i);
            blockbenchModel.textures = [];
            updateProgress(75, 'Packaging textures...');
            const outputZip = new JSZip();
            const structureName = nbtInput.files[0]?.name.replace('.nbt', '') || 'structure';
            outputZip.file(`${structureName}.json`, JSON.stringify(blockbenchModel, null, 2));
            let textureCount = 0;

            for (const atlas of atlasTextures) {
                try {
                    outputZip.file(`generated_atlases/${atlas.path}.png`, atlas.blob);
                    textureCount++;
                } catch (e) {
                    console.error('Error packaging atlas:', atlas.path, e);
                }
            }

            for (const [path, tex] of usedTextures) {
                try {
                    if (path.startsWith('atlas_')) continue;

                    const blob = await tex.file.async('blob');
                    let namespace = 'minecraft';
                    let folder = 'block';
                    let filename = path.split('/').pop();
                    if (path.includes(':')) {
                        const parts = path.split(':');
                        namespace = parts[0];
                        const subParts = parts[1].split('/');
                        if (subParts.length > 1) {
                            folder = subParts[0];
                            filename = subParts[subParts.length - 1];
                        } else {
                            filename = subParts[0];
                        }
                    } else if (path.includes('assets/')) {
                        const match = path.match(/assets\/([^\/]+)\/textures\/([^\/]+)\//);
                        if (match) {
                            namespace = match[1];
                            folder = match[2];
                        }
                    }
                    if (!filename.endsWith('.png')) filename += '.png';
                    outputZip.file(`${namespace}/${folder}/${filename}`, blob);
                    textureCount++;
                } catch (e) {
                    console.error('Error packaging texture:', path, e);
                }
            }
            generatedModel = {
                model: blockbenchModel,
                textureMapping: Array.from(usedTextures.keys()).map(path => path.split('/').pop().replace('.png', '')),
                blockTypeToTexture: Object.fromEntries(blockTypeToTexture)
            };
            generatedZip = await outputZip.generateAsync({
                type: 'blob'
            });
            document.getElementById('downloadSection').classList.add('show');
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('blockCount').textContent = blocks.length;
            document.getElementById('elementCount').textContent = blockbenchModel.elements.length;
            document.getElementById('textureCountStat').textContent = textureCount;
            document.getElementById('textureCount').textContent = textureCount;
            await renderTextures();
            updateProgress(100, 'Complete!');
            hideProgress();
            showToast(`Conversion complete! ${blockbenchModel.elements.length} elements, ${textureCount} textures`, 'success', {
                clearPrevious: true,
                duration: 5000
            });
        } catch (error) {
            hideProgress();
            showToast('Conversion error: ' + error.message, 'error');
            console.error(error);
        }
    }

    function downloadModel() {
        if (generatedZip) {
            const url = URL.createObjectURL(generatedZip);
            const a = document.createElement('a');
            a.href = url;
            const structureName = nbtInput.files[0]?.name.replace('.nbt', '') || 'structure';
            a.download = `${structureName}_converted.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Download started!', 'success');
        }
    }

    function previewModel() {
        if (!nbtData || !resourcesZip) {
            showToast('No structure data available to preview', 'error');
            return;
        }
        const modalHTML = `
<div class="modal-overlay show" id="previewModal" style="z-index: 4000;">
<div class="preview-modal">
<div class="preview-modal-header">
    <div class="preview-modal-title">Structure Preview</div>
    <button class="modal-close" onclick="closePreviewModal()">
        <img src="assets/buttons/exit.png" alt="Close">
    </button>
</div>

<div class="preview-modal-body">
    <div class="preview-settings-panel" id="previewSettingsPanel">
        <div class="preview-settings-header">
            <span>Settings</span>
        </div>
        <div class="preview-settings-content" id="previewSettingsContent">
<div class="preview-setting-group">
<label class="preview-setting-label">Colors</label>

<div class="preview-color-row">
<label>Sky Color</label>
<input type="color" id="previewSkyColor" value="#78a7ff" class="preview-color-input" onchange="updateSkyColor(this.value)">
</div>

<div class="preview-color-row">
<label>Grass Color</label>
<input type="color" id="previewGrassColor" value="#7cbd6b" class="preview-color-input" onchange="updateTintColor('grass', this.value)">
</div>

<div class="preview-color-row">
<label>Foliage Color</label>
<input type="color" id="previewFoliageColor" value="#6ba861" class="preview-color-input" onchange="updateTintColor('foliage', this.value)">
</div>

<div class="preview-color-row">
<label>Water Color</label>
<input type="color" id="previewWaterColor" value="#3F76E4" class="preview-color-input" onchange="updateTintColor('water', this.value)">
</div>
</div>

            <div class="preview-setting-group">
                <label class="preview-checkbox-label">
                    <input type="checkbox" id="previewOrthographic" onchange="toggleOrthographic(this.checked)">
                    <span>Orthographic Camera</span>
                </label>
            </div>

            <div class="preview-setting-group">
                <label class="preview-setting-label">Preset Angles</label>
                <div class="preview-angle-buttons">
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('front')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Front</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('back')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Back</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('left')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Left</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('right')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Right</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('top')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Top</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                    <button class="minecraft-button small preview-angle-button" onclick="setPreviewAngle('isometric')">
                        <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                        <div class="minecraft-button-section"><div class="minecraft-button-name">Iso-Right</div></div>
                        <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                    </button>
                </div>
            </div>

            <div class="preview-setting-group">
<label class="preview-setting-label">Screenshot Background</label>
<select id="screenshotBgType" class="preview-color-input" style="height: auto; padding: 8px;" onchange="updateScreenshotBgType(this.value)">
<option value="transparent">Transparent</option>
<option value="skyColor">Sky Color</option>
<option value="texture">Block Texture</option>
<option value="image">Custom Image</option>
</select>
</div>

<div class="preview-setting-group" id="textureSelectGroup" style="display: none;">
<label class="preview-setting-label">Select Texture</label>
<input type="text" id="textureSearch" placeholder="Search textures..."
   style="width: 100%; padding: 8px; background: #1a1a1a; border: 2px solid #0a0a0a; color: #e6e6e6; font-size: 12px; margin-bottom: 10px;"
   oninput="filterTextureGrid(this.value)">
<div id="textureGridContainer" style="max-height: 200px; overflow-y: auto; background: #1a1a1a; border: 2px solid #0a0a0a; padding: 10px;">
<div id="screenshotTextureGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 6px;">
</div>
</div>
</div>

<div class="preview-setting-group" id="imageUploadGroup" style="display: none;">
<label class="preview-setting-label">Upload Image</label>
<label class="upload-button" style="display: block; text-align: center;">
<input type="file" accept="image/*" id="screenshotBgImage" onchange="handleScreenshotImageUpload(this.files[0])" style="display: none;">
<span>Choose Image</span>
</label>
<div id="imageFileName" style="color: #a0a0a0; font-size: 11px; margin-top: 5px; text-align: center;"></div>
</div>

<div class="preview-setting-group" id="bgScaleGroup" style="display: none;">
<label class="preview-setting-label">Background Scale: <span id="bgScaleValue">1.0</span>x</label>
<input type="range" id="bgScaleSlider" min="0.1" max="5.0" step="0.1" value="1.0"
style="width: 100%; cursor: pointer;"
onclick="event.stopPropagation()"
onmousedown="event.stopPropagation()"
oninput="updateBgScale(this.value)"
onchange="updateBgScale(this.value)">
</div>

            <div class="preview-setting-group">
                <button class="minecraft-button success preview-screenshot-button" onclick="takeScreenshot()">
                    <div class="minecraft-button-left-outline"></div><div class="minecraft-button-right-outline"></div>
                    <div class="minecraft-button-section"><div class="minecraft-button-name">Take Screenshot</div></div>
                    <div class="minecraft-button-dark-strip"></div><div class="minecraft-button-bottom-outline"></div><div class="minecraft-button-shadow"></div>
                </button>
            </div>
            </div>
    </div>

    <div class="preview-viewport-wrapper">

        <div class="preview-settings-tab" onclick="togglePreviewSettings()">
            <img src="assets/wiki/buttons/dropdown_arrow.png" alt="Settings">
        </div>

        <div id="previewCanvas"></div>

        <div class="preview-controls">
            <div class="preview-info" id="previewInfo">Loading...</div>
        </div>
    </div>
</div>
</div>
</div>
`;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        initPreview();
    }
    async function initPreview() {
        const container = document.getElementById('previewCanvas');
        previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x78A7FF);
        previewScene.fog = new THREE.Fog(0x3F76E4, 800, 1000);
        const aspect = container.clientWidth / container.clientHeight;
        previewCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        previewRenderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        previewRenderer.setSize(container.clientWidth, container.clientHeight);
        previewRenderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(previewRenderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        previewScene.add(ambientLight);
        const topLight = new THREE.DirectionalLight(0xffffff, 0.46);
        topLight.position.set(0, 100, 0);
        previewScene.add(topLight);
        const bottomLight = new THREE.DirectionalLight(0xffffff, -0.02);
        bottomLight.position.set(0, -100, 0);
        previewScene.add(bottomLight);
        const northLight = new THREE.DirectionalLight(0xffffff, 0.3);
        northLight.position.set(0, 0, -100);
        previewScene.add(northLight);
        const southLight = new THREE.DirectionalLight(0xffffff, 0.3);
        southLight.position.set(0, 0, 100);
        previewScene.add(southLight);
        const westLight = new THREE.DirectionalLight(0xffffff, 0.1);
        westLight.position.set(-100, 0, 0);
        previewScene.add(westLight);
        const eastLight = new THREE.DirectionalLight(0xffffff, 0.1);
        eastLight.position.set(100, 0, 0);
        previewScene.add(eastLight);
        await loadStructureIntoScene();
        const size = nbtData.size || [16, 16, 16];
        const maxDim = Math.max(size[0], size[1], size[2]);
        const blockTypeToTexture = new Map();
        const distance = maxDim * 1.5;
        previewCamera.position.set(distance, distance * 0.7, distance);
        previewCamera.lookAt(size[0] * 8, size[1] * 8, size[2] * 8);
        setupBasicControls();
        window.addEventListener('resize', onPreviewResize);
        animatePreview();
    }

    function setupBasicControls() {
        let isDragging = false;
        let isPanning = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };
        const size = nbtData.size || [16, 16, 16];
        const target = new THREE.Vector3(size[0] * 8, size[1] * 8, size[2] * 8);
        previewRenderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            } else if (e.button === 2 || e.button === 1) {
                isPanning = true;
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            }
            e.preventDefault();
        });
        previewRenderer.domElement.addEventListener('mousemove', (e) => {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            if (isDragging) {
                const rotationSpeed = 0.005;
                const offset = previewCamera.position.clone().sub(target);
                const spherical = new THREE.Spherical().setFromVector3(offset);
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi += deltaY * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                offset.setFromSpherical(spherical);
                previewCamera.position.copy(target).add(offset);
                previewCamera.lookAt(target);
            } else if (isPanning) {
                const panSpeed = 0.25;
                const offset = new THREE.Vector3();
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                previewCamera.getWorldDirection(new THREE.Vector3());
                right.setFromMatrixColumn(previewCamera.matrix, 0);
                up.setFromMatrixColumn(previewCamera.matrix, 1);
                offset.add(right.multiplyScalar(-deltaX * panSpeed));
                offset.add(up.multiplyScalar(deltaY * panSpeed));
                target.add(offset);
                previewCamera.position.add(offset);
            }
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });
        document.addEventListener('mouseup', () => {
            isDragging = false;
            isPanning = false;
        });
        previewRenderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        previewRenderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (previewCamera.isOrthographicCamera) {
                const zoomSpeed = 0.05;
                const currentZoom = previewCamera.zoom;
                const newZoom = Math.max(0.1, Math.min(10, currentZoom - e.deltaY * zoomSpeed * 0.01));
                previewCamera.zoom = newZoom;
                previewCamera.updateProjectionMatrix();
            } else {
                const zoomSpeed = 0.1;
                const offset = previewCamera.position.clone().sub(target);
                const distance = offset.length();
                const newDistance = Math.max(10, Math.min(1000, distance + e.deltaY * zoomSpeed));
                offset.normalize().multiplyScalar(newDistance);
                previewCamera.position.copy(target).add(offset);
            }
        });
    }
    async function loadStructureIntoScene() {
        const textureCache = new Map();
        animatedTextures = new Map();
        if (!generatedModel || !usedTextures) {
            document.getElementById('previewInfo').textContent = 'Please convert the structure first before previewing.';
            return;
        }
        try {
            const model = generatedModel.model;
            const textureMapping = generatedModel.textureMapping;
            const textureLoader = new THREE.TextureLoader();
            document.getElementById('previewInfo').textContent = `Loading ${usedTextures.size} textures...`;
            for (const [texturePath, textureResult] of usedTextures) {
                const fileName = texturePath.split('/').pop().replace('.png', '');
                const blob = await textureResult.file.async('blob');
                const url = URL.createObjectURL(blob);
                const mcmetaPath = texturePath.replace('.png', '.png.mcmeta');
                let animationData = null;
                try {
                    const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
                    const mcmetaFile = await findFile(mcmetaPath, allZips);
                    if (mcmetaFile) {
                        const mcmetaContent = await mcmetaFile.async('string');
                        const mcmetaJson = JSON.parse(mcmetaContent);
                        if (mcmetaJson.animation) {
                            animationData = mcmetaJson.animation;
                        }
                    }
                } catch (e) {}
                if (!animationData) {
                    const img = new Image();
                    img.src = url;
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                    if (img.width > 0 && img.height > img.width) {
                        const frameCount = Math.floor(img.height / img.width);
                        animationData = {
                            frametime: 1,
                            frames: Array.from({
                                length: frameCount
                            }, (_, i) => i)
                        };
                    }
                }
                if (animationData) {
                    const img = new Image();
                    img.src = url;
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                    const frameSize = img.width;
                    const frameHeight = img.width;
                    let frameOrder;
                    if (Array.isArray(animationData.frames)) {
                        frameOrder = animationData.frames;
                    } else if (typeof animationData.frames === 'number') {
                        frameOrder = Array.from({
                            length: animationData.frames
                        }, (_, i) => i);
                    } else {
                        const totalFrames = Math.floor(img.height / frameSize);
                        frameOrder = Array.from({
                            length: totalFrames
                        }, (_, i) => i);
                    }
                    const frameCache = [];
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameSize;
                    tempCanvas.height = frameHeight;
                    const tempCtx = tempCanvas.getContext('2d', {
                        willReadFrequently: true
                    });
                    tempCtx.imageSmoothingEnabled = false;
                    for (let i = 0; i < frameOrder.length; i++) {
                        const frameData = frameOrder[i];
                        const frameIndex = typeof frameData === 'object' ? frameData.index : frameData;
                        tempCtx.clearRect(0, 0, frameSize, frameHeight);
                        tempCtx.drawImage(
                            img,
                            0, frameIndex * frameHeight,
                            frameSize, frameHeight,
                            0, 0,
                            frameSize, frameHeight
                        );
                        frameCache.push(tempCtx.getImageData(0, 0, frameSize, frameHeight));
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = frameSize;
                    canvas.height = frameHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    const animTexture = new THREE.CanvasTexture(canvas);
                    animTexture.magFilter = THREE.NearestFilter;
                    animTexture.minFilter = THREE.NearestFilter;
                    animTexture.wrapS = THREE.RepeatWrapping;
                    animTexture.wrapT = THREE.RepeatWrapping;
                    animTexture.flipY = false;
                    textureCache.set(fileName, animTexture);
                    animatedTextures.set(fileName, {
                        texture: animTexture,
                        frameCache: frameCache,
                        frameOrder: frameOrder,
                        frametime: animationData.frametime || 1,
                        interpolate: animationData.interpolate || false,
                        currentFrameIndex: 0,
                        frameProgress: 0,
                        canvas: canvas,
                        ctx: ctx,
                        tempCanvas: tempCanvas
                    });
                } else {
                    await new Promise((resolve) => {
                        textureLoader.load(url, (texture) => {
                            texture.magFilter = THREE.NearestFilter;
                            texture.minFilter = THREE.NearestFilter;
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            texture.flipY = false;
                            textureCache.set(fileName, texture);
                            resolve();
                        }, undefined, (err) => {
                            console.error('Error loading texture:', texturePath, err);
                            resolve();
                        });
                    });
                }
            }
            document.getElementById('previewInfo').textContent = `Creating 3D geometry...`;
            const CHUNK_SIZE = 16;
            const chunks = new Map();
            for (let i = 0; i < model.elements.length; i++) {
                const element = model.elements[i];
                const from = element.from;
                const to = element.to;
                const width = to[0] - from[0];
                const height = to[1] - from[1];
                const depth = to[2] - from[2];
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const chunkX = Math.floor(from[0] / (CHUNK_SIZE * 16));
                const chunkY = Math.floor(from[1] / (CHUNK_SIZE * 16));
                const chunkZ = Math.floor(from[2] / (CHUNK_SIZE * 16));
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;
                if (!chunks.has(chunkKey)) {
                    const chunkGroup = new THREE.Group();
                    chunkGroup.name = chunkKey;
                    chunks.set(chunkKey, chunkGroup);
                }
                const chunkGroup = chunks.get(chunkKey);
                const materials = [];
                const faceOrder = ['east', 'west', 'up', 'down', 'south', 'north'];
                const faceTintInfo = [];
                for (let j = 0; j < 6; j++) {
                    const faceName = faceOrder[j];
                    const faceData = element.faces?.[faceName];
                    if (!faceData) {
                        materials.push(new THREE.MeshBasicMaterial({
                            visible: false
                        }));
                        faceTintInfo.push(null);
                        continue;
                    }
                    const faceTexturePath = faceData.texture;
                    const textureFileName = (typeof faceTexturePath === 'string') ?
                        faceTexturePath.split('/').pop().replace('.png', '') :
                        null;
                    let texture = textureFileName ? textureCache.get(textureFileName) : null;
                    if (!texture && textureMapping.length > 0) {
                        texture = textureCache.get(textureMapping[0]);
                    }
                    if (texture) {
                        const clonedTexture = texture.clone();
                        clonedTexture.needsUpdate = true;
if (faceData.uv) {
    const uv = faceData.uv;
    const uvAttr = geometry.attributes.uv;
    const faceUVIndex = j * 4;

    let u1 = uv[0] / 16;
    let v1 = uv[1] / 16;
    let u2 = uv[2] / 16;
    let v2 = uv[3] / 16;

    const rotation = faceData.rotation || 0;

    if (uvAttr && uvAttr.array.length > faceUVIndex * 2 + 7) {
        let corners = [
            [u1, v1],
            [u2, v1],
            [u1, v2],
            [u2, v2]
        ];

        if (rotation === 90) {
            corners = [
                [u1, v2],
                [u1, v1],
                [u2, v2],
                [u2, v1]
            ];
        } else if (rotation === 180) {
            corners = [
                [u2, v2],
                [u1, v2],
                [u2, v1],
                [u1, v1]
            ];
        } else if (rotation === 270) {
            corners = [
                [u2, v1],
                [u2, v2],
                [u1, v1],
                [u1, v2]
            ];
        }

        uvAttr.setXY(faceUVIndex + 0, corners[0][0], corners[0][1]);
        uvAttr.setXY(faceUVIndex + 1, corners[1][0], corners[1][1]);
        uvAttr.setXY(faceUVIndex + 2, corners[2][0], corners[2][1]);
        uvAttr.setXY(faceUVIndex + 3, corners[3][0], corners[3][1]);
        uvAttr.needsUpdate = true;
    }
}
                        const mat = new THREE.MeshLambertMaterial({
                            map: clonedTexture,
                            transparent: true,
                            alphaTest: 0.1,
                            side: THREE.FrontSide
                        });
                        if (faceData.tintindex !== undefined) {
                            const tintType = getTintType(element.name);
                            if (tintType && tintColors[tintType]) {
                                mat.color.setHex(tintColors[tintType]);
                                mat.userData.hasTint = true;
                                faceTintInfo.push(tintType);
                            } else {
                                faceTintInfo.push(null);
                            }
                        } else {
                            faceTintInfo.push(null);
                        }
                        materials.push(mat);
                    } else {
                        materials.push(new THREE.MeshLambertMaterial({
                            color: 0x888888
                        }));
                        faceTintInfo.push(null);
                    }
                }
                const mesh = new THREE.Mesh(geometry, materials);
                const tintType = faceTintInfo.find(t => t !== null);
                if (tintType) {
                    mesh.userData.tintType = tintType;
                }
                mesh.position.set(
                    from[0] + width / 2,
                    from[1] + height / 2,
                    from[2] + depth / 2
                );
                chunkGroup.add(mesh);
                if (i % 100 === 0) {
                    document.getElementById('previewInfo').textContent =
                        `Creating geometry: ${i}/${model.elements.length} (${Math.round(i/model.elements.length*100)}%)`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            for (const chunk of chunks.values()) {
                if (chunk.children.length > 0) {
                    previewScene.add(chunk);
                }
            }
            document.getElementById('previewInfo').innerHTML =
                `Loaded ${model.elements.length} elements in ${chunks.size} chunks &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Some textures may be inaccurate in preview`;
            populateTextureDropdown();
        } catch (error) {
            console.error('Error loading model:', error);
            document.getElementById('previewInfo').textContent = 'Error loading model: ' + error.message;
        }
    }

    function animatePreview() {
        previewAnimationFrame = requestAnimationFrame(animatePreview);
        const deltaTime = 16.67;
        for (const [fileName, animData] of animatedTextures) {
            const fps = 20 / animData.frametime;
            const msPerFrame = 1000 / fps;
            animData.frameProgress += deltaTime / msPerFrame;
            while (animData.frameProgress >= 1.0) {
                animData.currentFrameIndex = (animData.currentFrameIndex + 1) % animData.frameCache.length;
                animData.frameProgress -= 1.0;
            }
            if (animData.interpolate && animData.frameProgress > 0 && animData.frameProgress < 1) {
                const currentData = animData.frameCache[animData.currentFrameIndex];
                const nextFrameIndex = (animData.currentFrameIndex + 1) % animData.frameCache.length;
                const nextData = animData.frameCache[nextFrameIndex];
                const interpolatedData = animData.ctx.createImageData(animData.canvas.width, animData.canvas.height);
                const progress = animData.frameProgress;
                for (let i = 0; i < currentData.data.length; i += 4) {
                    interpolatedData.data[i] = currentData.data[i] + (nextData.data[i] - currentData.data[i]) * progress;
                    interpolatedData.data[i + 1] = currentData.data[i + 1] + (nextData.data[i + 1] - currentData.data[i + 1]) * progress;
                    interpolatedData.data[i + 2] = currentData.data[i + 2] + (nextData.data[i + 2] - currentData.data[i + 2]) * progress;
                    interpolatedData.data[i + 3] = currentData.data[i + 3];
                }
                animData.ctx.putImageData(interpolatedData, 0, 0);
            } else {
                animData.ctx.putImageData(animData.frameCache[animData.currentFrameIndex], 0, 0);
            }
            animData.texture.needsUpdate = true;
        }
        if (previewControls && previewControls.update) {
            previewControls.update();
        }
        previewRenderer.render(previewScene, previewCamera);
    }

    function onPreviewResize() {
        const container = document.getElementById('previewCanvas');
        if (!container || !previewCamera || !previewRenderer) return;
        const width = container.clientWidth;
        const height = container.clientHeight;
        previewCamera.aspect = width / height;
        previewCamera.updateProjectionMatrix();
        previewRenderer.setSize(width, height);
    }

    function closePreviewModal() {
        if (previewAnimationFrame) {
            cancelAnimationFrame(previewAnimationFrame);
            previewAnimationFrame = null;
        }
        animatedTextures.clear();
        animatedTextures = new Map();
        if (previewRenderer) {
            previewRenderer.dispose();
            previewRenderer = null;
        }
        if (previewScene) {
            previewScene.traverse((object) => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => mat.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
            previewScene = null;
        }
        previewCamera = null;
        previewControls = null;
        window.removeEventListener('resize', onPreviewResize);
        const modal = document.getElementById('previewModal');
        if (modal) {
            modal.remove();
        }
    }

    function toggleTextureDropdown() {
        const grid = document.getElementById('textureGrid');
        const container = document.getElementById('textureDropdown');
        if (grid.classList.contains('open')) {
            const fullHeight = grid.scrollHeight + 'px';
            grid.style.maxHeight = fullHeight;
            requestAnimationFrame(() => {
                grid.style.maxHeight = '0px';
            });
        } else {
            grid.classList.add('open');
            grid.style.maxHeight = '0px';
            requestAnimationFrame(() => {
                grid.style.maxHeight = grid.scrollHeight + 'px';
            });
        }
        grid.addEventListener('transitionend', function handler() {
            grid.removeEventListener('transitionend', handler);
            if (grid.style.maxHeight === '0px') {
                grid.classList.remove('open');
            }
        });
        container.classList.toggle('expanded');
        textureTargetRotation += 180;
        if (!isTextureArrowAnimating) {
            updateTextureArrow();
        }
    }
    async function renderTextures() {
        const content = document.getElementById('textureContent');
        content.innerHTML = '';
        for (const [texturePath, textureResult] of usedTextures) {
            const fileName = texturePath.split('/').pop().replace('.png', '');
            const item = document.createElement('div');
            item.className = 'texture-item';
            item.style.position = 'relative';
            try {
                const blob = await textureResult.file.async('blob');
                const url = URL.createObjectURL(blob);
                textureMap.set(fileName, blob);
                const mcmetaPath = texturePath.replace('.png', '.png.mcmeta');
                let animationData = null;
                try {
                    const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
                    const mcmetaFile = await findFile(mcmetaPath, allZips);
                    if (mcmetaFile) {
                        const mcmetaContent = await mcmetaFile.async('string');
                        const mcmetaJson = JSON.parse(mcmetaContent);
                        if (mcmetaJson.animation) {
                            animationData = mcmetaJson.animation;
                        }
                    }
                } catch (e) {}
                if (!animationData) {
                    const img = new Image();
                    img.src = url;
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                    if (img.width > 0 && img.height > img.width) {
                        const frameCount = Math.floor(img.height / img.width);
                        animationData = {
                            frametime: 1,
                            frames: Array.from({
                                length: frameCount
                            }, (_, i) => i)
                        };
                    }
                }
                if (animationData) {
                    const img = new Image();
                    img.src = url;
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                    const canvas = document.createElement('canvas');
                    const frameSize = img.width;
                    canvas.width = frameSize;
                    canvas.height = frameSize;
                    const ctx = canvas.getContext('2d', {
                        willReadFrequently: true
                    });
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(img, 0, 0, frameSize, frameSize, 0, 0, frameSize, frameSize);
                    const firstFrameUrl = canvas.toDataURL();
                    item.onclick = () => showTextureModal(fileName, textureResult, animationData);
                    item.innerHTML = `
<img class="texture-preview" src="${firstFrameUrl}" alt="${fileName}">
<div class="texture-name">${fileName}</div>
<div class="animated-indicator"><img src="assets/wiki/buttons/camera_symbol.png" style="width: 12px; height: 12px; image-rendering: pixelated; filter: brightness(0) invert(1);"></div>
`;
                } else {
                    item.onclick = () => showTextureModal(fileName, textureResult, animationData);
                    item.innerHTML = `
<img class="texture-preview" src="${url}" alt="${fileName}">
<div class="texture-name">${fileName}</div>
`;
                }
            } catch (e) {
                console.error('Error rendering texture:', e);
            }
            content.appendChild(item);
        }
    }

    function updateTextureArrow() {
        if (textureCurrentRotation === textureTargetRotation || isTextureArrowAnimating) return;
        const arrow = document.getElementById('textureArrow');
        isTextureArrowAnimating = true;
        let nextRotation = textureCurrentRotation + 180;
        arrow.style.transform = `rotate(${nextRotation}deg)`;
        arrow.addEventListener('transitionend', function handler(e) {
            if (e.propertyName !== 'transform') return;
            arrow.removeEventListener('transitionend', handler);
            textureCurrentRotation = nextRotation;
            if (textureCurrentRotation >= 360) {
                arrow.style.transition = 'none';
                textureCurrentRotation -= 360;
                textureTargetRotation -= 360;
                arrow.style.transform = `rotate(${textureCurrentRotation}deg)`;
                void arrow.offsetWidth;
                arrow.style.transition = 'transform 0.4s ease';
            }
            isTextureArrowAnimating = false;
            setTimeout(updateTextureArrow, 10);
        });
    }
    let currentAnimationFrame = null;
    const checkboxStyle = document.createElement('style');
    checkboxStyle.textContent = `
input[type="checkbox"] {
cursor: pointer;
width: 16px;
height: 16px;
appearance: none;
-webkit-appearance: none;
background-image: url('assets/buttons/checkbox.png');
background-size: 16px 16px;
background-repeat: no-repeat;
background-position: center;
border: none;
box-shadow: none;
background-color: transparent;
border-radius: 0;
image-rendering: -moz-crisp-edges;
image-rendering: -webkit-crisp-edges;
image-rendering: pixelated;
image-rendering: crisp-edges;
}

input[type="checkbox"]:checked {
background-image: url('assets/buttons/checkboxchecked.png');
}
`;
    document.head.appendChild(checkboxStyle);
    async function showTextureModal(fileName, textureResult, animationData) {
        currentTextureName = fileName;
        textureResult.file.async('blob').then(async blob => {
            currentTextureBlob = blob;
            const url = URL.createObjectURL(blob);
            const interpolateText = animationData?.interpolate ? '  Interpolated' : '';
            document.getElementById('textureModalTitle').textContent = fileName + interpolateText;
            const modalBody = document.querySelector('.texture-modal-body');
            modalBody.innerHTML = '';
            if (animationData) {
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; gap: 20px; width: 100%;';
                const leftPanel = document.createElement('div');
                leftPanel.style.cssText = 'flex: 0 0 120px; display: flex; flex-direction: column; gap: 10px;';
                const centerPanel = document.createElement('div');
                centerPanel.style.cssText = 'flex: 1; display: flex; flex-direction: column; align-items: center;';
                const canvas = document.createElement('canvas');
                canvas.className = 'texture-modal-canvas';
                canvas.width = 384;
                canvas.height = 384;
                canvas.style.minWidth = '384px';
                canvas.style.minHeight = '384px';
                centerPanel.appendChild(canvas);
                const controlsDiv = document.createElement('div');
                controlsDiv.style.cssText = 'margin-top: 15px; display: flex; gap: 10px; align-items: center; justify-content: center;';
                const playBtn = document.createElement('button');
                playBtn.className = 'minecraft-button small';
                playBtn.innerHTML = `
<div class="minecraft-button-left-outline"></div>
<div class="minecraft-button-right-outline"></div>
<div class="minecraft-button-section">
<div class="minecraft-button-name" style="font-size: 16px; line-height: 1; padding-bottom: 5px;"></div>
</div>
<div class="minecraft-button-dark-strip"></div>
<div class="minecraft-button-bottom-outline"></div>
<div class="minecraft-button-shadow"></div>
`;
                playBtn.style.height = '30px';
                playBtn.style.minWidth = '60px';
                const fpsLabel = document.createElement('div');
                fpsLabel.style.cssText = 'font-size: 12px; color: #cccccc; font-family: "Minecraft Ten", sans-serif;';
                fpsLabel.textContent = 'FPS:';
                const defaultFrametime = animationData.frametime || 1;
                const defaultFPS = 20 / defaultFrametime;
                const fpsInput = document.createElement('input');
                fpsInput.type = 'number';
                fpsInput.min = '1';
                fpsInput.max = '60';
                fpsInput.value = defaultFPS.toString();
                fpsInput.style.cssText = 'width: 60px; padding: 5px; background: #1a1a1a; border: 2px solid #0a0a0a; color: #e6e6e6; font-family: "Minecraft Ten", sans-serif; font-size: 12px;';
                const interpolateCheckbox = document.createElement('input');
                interpolateCheckbox.type = 'checkbox';
                interpolateCheckbox.id = 'interpolateCheckbox';
                interpolateCheckbox.checked = animationData.interpolate || false;
                const interpolateLabel = document.createElement('label');
                interpolateLabel.htmlFor = 'interpolateCheckbox';
                interpolateLabel.style.cssText = 'font-size: 12px; color: #cccccc; font-family: "Minecraft Ten", sans-serif; cursor: pointer; margin-left: 10px;';
                interpolateLabel.textContent = 'Interpolate';
                controlsDiv.appendChild(playBtn);
                controlsDiv.appendChild(fpsLabel);
                controlsDiv.appendChild(fpsInput);
                controlsDiv.appendChild(interpolateCheckbox);
                controlsDiv.appendChild(interpolateLabel);
                centerPanel.appendChild(controlsDiv);
                mainContainer.appendChild(leftPanel);
                mainContainer.appendChild(centerPanel);
                modalBody.appendChild(mainContainer);
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.src = url;
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.onerror = resolve;
                });
                const frameWidth = img.width;
                const frameHeight = img.width;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frameWidth;
                tempCanvas.height = frameHeight;
                const tempCtx = tempCanvas.getContext('2d', {
                    willReadFrequently: true
                });
                let frameOrder;
                if (Array.isArray(animationData.frames)) {
                    frameOrder = animationData.frames;
                } else if (typeof animationData.frames === 'number') {
                    frameOrder = Array.from({
                        length: animationData.frames
                    }, (_, i) => i);
                } else {
                    const totalFrames = Math.floor(img.height / frameWidth);
                    frameOrder = Array.from({
                        length: totalFrames
                    }, (_, i) => i);
                }
                let currentFrameIndex = 0;
                let isPlaying = false;
                let animationInterval = null;
                let customFPS = defaultFPS;
                let interpolationEnabled = animationData.interpolate || false;
                const frameCache = new Map();

                function getFrameImageData(frameIdx) {
                    if (frameCache.has(frameIdx)) {
                        return frameCache.get(frameIdx);
                    }
                    const frameData = frameOrder[frameIdx];
                    const frameIndex = typeof frameData === 'object' ? frameData.index : frameData;
                    tempCtx.clearRect(0, 0, frameWidth, frameHeight);
                    tempCtx.drawImage(
                        img,
                        0, frameIndex * frameHeight,
                        frameWidth, frameHeight,
                        0, 0,
                        frameWidth, frameHeight
                    );
                    const imageData = tempCtx.getImageData(0, 0, frameWidth, frameHeight);
                    frameCache.set(frameIdx, imageData);
                    return imageData;
                }
                frameOrder.forEach((frameData, idx) => {
                    const frameIndex = typeof frameData === 'object' ? frameData.index : frameData;
                    const frameContainer = document.createElement('div');
                    frameContainer.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 4px; border: 2px solid #1a1a1a; background: #2a2a2a;';
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = 48;
                    thumbCanvas.height = 48;
                    thumbCanvas.style.cssText = 'image-rendering: pixelated; flex-shrink: 0;';
                    const thumbCtx = thumbCanvas.getContext('2d');
                    thumbCtx.imageSmoothingEnabled = false;
                    thumbCtx.drawImage(
                        img,
                        0, frameIndex * frameHeight,
                        frameWidth, frameHeight,
                        0, 0,
                        48, 48
                    );
                    const frameLabel = document.createElement('div');
                    frameLabel.style.cssText = 'font-size: 12px; color: #cccccc; font-family: "Minecraft Ten", sans-serif;';
                    frameLabel.textContent = idx.toString();
                    frameContainer.appendChild(thumbCanvas);
                    frameContainer.appendChild(frameLabel);
                    frameContainer.onclick = () => {
                        if (isPlaying) {
                            stopAnimation();
                        }
                        currentFrameIndex = idx;
                        drawFrame(0);
                    };
                    frameContainer.dataset.frameIndex = idx;
                    leftPanel.appendChild(frameContainer);
                });

                function updateFrameHighlight() {
                    leftPanel.querySelectorAll('div[data-frame-index]').forEach((container, idx) => {
                        container.style.borderColor = idx === currentFrameIndex ? '#3453df' : '#1a1a1a';
                        container.style.background = idx === currentFrameIndex ? '#3a3a4a' : '#2a2a2a';
                    });
                }

                function drawFrame(progress = 0) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (interpolationEnabled && progress > 0 && progress < 1) {
                        const currentData = getFrameImageData(currentFrameIndex);
                        const nextFrameIndex = (currentFrameIndex + 1) % frameOrder.length;
                        const nextData = getFrameImageData(nextFrameIndex);
                        const interpolatedData = ctx.createImageData(frameWidth, frameHeight);
                        for (let i = 0; i < currentData.data.length; i += 4) {
                            const r1 = currentData.data[i];
                            const g1 = currentData.data[i + 1];
                            const b1 = currentData.data[i + 2];
                            const a1 = currentData.data[i + 3];
                            const r2 = nextData.data[i];
                            const g2 = nextData.data[i + 1];
                            const b2 = nextData.data[i + 2];
                            const a2 = nextData.data[i + 3];
                            interpolatedData.data[i] = r1 + (r2 - r1) * progress;
                            interpolatedData.data[i + 1] = g1 + (g2 - g1) * progress;
                            interpolatedData.data[i + 2] = b1 + (b2 - b1) * progress;
                            interpolatedData.data[i + 3] = a1;
                        }
                        tempCtx.putImageData(interpolatedData, 0, 0);
                        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
                    } else {
                        const frameData = frameOrder[currentFrameIndex];
                        const frameIndex = typeof frameData === 'object' ? frameData.index : frameData;
                        ctx.drawImage(
                            img,
                            0, frameIndex * frameHeight,
                            frameWidth, frameHeight,
                            0, 0,
                            canvas.width, canvas.height
                        );
                    }
                    updateFrameHighlight();
                }

                function startAnimation() {
                    if (isPlaying) return;
                    isPlaying = true;
                    playBtn.querySelector('.minecraft-button-name').textContent = '';
                    const msPerFrame = 1000 / customFPS;
                    let lastTime = performance.now();
                    let frameProgress = 0;

                    function animate(currentTime) {
                        if (!isPlaying) return;
                        const deltaTime = currentTime - lastTime;
                        lastTime = currentTime;
                        frameProgress += deltaTime / msPerFrame;
                        while (frameProgress >= 1.0) {
                            currentFrameIndex = (currentFrameIndex + 1) % frameOrder.length;
                            frameProgress -= 1.0;
                        }
                        if (interpolationEnabled) {
                            drawFrame(frameProgress);
                        } else {
                            drawFrame(0);
                        }
                        animationInterval = requestAnimationFrame(animate);
                    }
                    animationInterval = requestAnimationFrame(animate);
                }

                function stopAnimation() {
                    if (!isPlaying) return;
                    isPlaying = false;
                    playBtn.querySelector('.minecraft-button-name').textContent = '';
                    if (animationInterval) {
                        cancelAnimationFrame(animationInterval);
                        animationInterval = null;
                    }
                    drawFrame(0);
                }
                interpolateCheckbox.addEventListener('change', () => {
                    interpolationEnabled = interpolateCheckbox.checked;
                    if (!isPlaying) {
                        drawFrame(0);
                    }
                });
                fpsInput.addEventListener('input', (e) => {
                    const newFPS = parseInt(e.target.value) || defaultFPS;
                    customFPS = Math.max(1, Math.min(60, newFPS));
                    if (isPlaying) {
                        stopAnimation();
                        startAnimation();
                    }
                });
                playBtn.onclick = () => {
                    if (isPlaying) {
                        stopAnimation();
                    } else {
                        startAnimation();
                    }
                };
                drawFrame(0);
            } else {
                const img = document.createElement('img');
                img.className = 'texture-modal-image';
                img.src = url;
                modalBody.appendChild(img);
            }
            document.getElementById('textureModalOverlay').classList.add('show');
        });
    }

    function closeTextureModal(event) {
        if (event && event.target !== event.currentTarget) return;
        const modalBody = document.querySelector('.texture-modal-body');
        if (modalBody) {
            modalBody.innerHTML = '';
        }
        document.getElementById('textureModalOverlay').classList.remove('show');
    }

    function downloadCurrentTexture() {
        if (currentTextureBlob) {
            const url = URL.createObjectURL(currentTextureBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentTextureName + '.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Texture downloaded!', 'success');
        }
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    document.addEventListener('mousedown', (e) => {
        if (e.target.closest('.minecraft-button')) {
            const btn = e.target.closest('.minecraft-button');
            btn.classList.add('pressed');
        }
    });
    document.addEventListener('mouseup', (e) => {
        document.querySelectorAll('.minecraft-button.pressed').forEach(btn => {
            setTimeout(() => {
                btn.classList.remove('pressed');
            }, 150);
        });
    });

    function showHelp() {
        const helpHTML = `
<h3>What is this tool?</h3>
<p>This tool converts Minecraft NBT structure files into Blockbench-compatible 3D models.
It handles vanilla and modded blocks. The only exception is blocks that use an entity model.</p>

<h3>How to Use:</h3>

<p><strong>Step 1: Upload Minecraft Resources</strong></p>
<ul>
<li>Click or drag your Minecraft JAR file into the first upload box</li>
<li>Find your client JAR in: <code>.minecraft/versions/[version]/[version].jar</code></li>
<li>You can also use a ZIP file containing all of the Minecraft assets</li>
<li>This provides the vanilla block models and textures</li>
</ul>

<p><strong>Step 2: Upload NBT Structure File</strong></p>
<ul>
<li>Click or drag your .nbt structure file into the second upload box</li>
<li>Create structure files in-game using structure blocks</li>
<li>Find saved structures in: <code>.minecraft/saves/[world]/generated/minecraft/structures/</code></li>
</ul>

<p><strong>Step 3: Add Mod JARs (Optional)</strong></p>
<ul>
<li>If your structure contains modded blocks, add the mod JAR files</li>
<li>Click "+ Add Mod JAR" and select one or more mod files</li>
<li>The tool will automatically extract the mod ID from each JAR</li>
</ul>

<p><strong>Step 4: Convert</strong></p>
<ul>
<li>Once you've uploaded the required files, the "Convert" button will turn green</li>
<li>Click the button to start the conversion process</li>
<li>The tool will let you know if any block models are missing</li>
<li>A ZIP file will automatically download when complete</li>
</ul>

<p><strong>Missing Block Models</strong></p>
<ul>
<li>If you are missing any block models, the tool will bring up a menu with all of them</li>
<li>Each block requires a block model, blockstate, and texture</li>
<li>The texture can either be imported, or it can be taken from a directory</li>
<p></p>
<p>Note: Most of the time block models have no elements or are just missing because they are rendered by an entity model. In that situation you must either find a JSON of it, or recreate the model and export the JSON file.</p>
</ul>

<h3>What's in the Downloaded ZIP?</h3>

<ul>
<li><strong>model_name.json</strong> - The main Blockbench model file containing all block elements</li>
<li><strong>textures/</strong> folder - Contains only the textures used by blocks in your structure</li>
</ul>

<h3>Opening in Blockbench:</h3>

<ul>
<li>Extract the downloaded ZIP file</li>
<li>Open Blockbench and go to File > Open Model</li>
<li>Select the <code>model_name.json</code> file</li>
<li>Textures will automatically load from the textures folder</li>
</ul>

<h3>Need Help?</h3>
<p>If you encounter issues:</p>
<ul>
<li>Report bugs on <a href="https://github.com/PotatoWolfie/potatowolfie.github.io/issues" target="_blank">GitHub</a></li>
<li>Include details about your structure size and which blocks are causing issues</li>
<li>Mention if you're using modded content and which mods</li>
</ul>

<h3>Credits:</h3>
<p>Tool created by <strong>PotatoWolfie</strong>.</p>
`;
        document.getElementById('helpModalBody').innerHTML = helpHTML;
        document.getElementById('helpModalOverlay').classList.add('show');
    }

    function closeHelpModal(event) {
        if (event && event.target !== event.currentTarget) return;
        document.getElementById('helpModalOverlay').classList.remove('show');
    }
    document.addEventListener('mousedown', (e) => {
        if (e.target.closest('.help-button')) {
            const btn = e.target.closest('.help-button');
            btn.classList.add('pressed');
        }
    });
    document.addEventListener('mouseup', (e) => {
        document.querySelectorAll('.help-button.pressed').forEach(btn => {
            setTimeout(() => {
                btn.classList.remove('pressed');
            }, 150);
        });
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeHelpModal();
        }
    });

    function togglePreviewSettings() {
        const panel = document.getElementById('previewSettingsPanel');
        panel.classList.toggle('open');
        let steps = 0;
        const interval = setInterval(() => {
            onPreviewResize();
            steps++;
            if (steps > 35) clearInterval(interval);
        }, 10);
    }

    function updateSkyColor(color) {
        const colorHex = parseInt(color.replace('#', ''), 16);
        previewScene.background.setHex(colorHex);
        previewScene.fog.color.setHex(colorHex);
    }

    function toggleOrthographic(isOrtho) {
        const container = document.getElementById('previewCanvas');
        const size = nbtData.size || [16, 16, 16];
        const target = new THREE.Vector3(size[0] * 8, size[1] * 8, size[2] * 8);
        const currentPos = previewCamera.position.clone();
        let distance = currentPos.distanceTo(target);
        const direction = currentPos.sub(target).normalize();
        if (!isOrtho && previewCamera.isOrthographicCamera) {
            distance = distance / previewCamera.zoom;
        }
        const aspect = container.clientWidth / container.clientHeight;
        if (isOrtho) {
            const frustumHeight = 2 * distance * Math.tan((75 * Math.PI) / 360);
            const frustumWidth = frustumHeight * aspect;
            previewCamera = new THREE.OrthographicCamera(
                -frustumWidth / 2,
                frustumWidth / 2,
                frustumHeight / 2,
                -frustumHeight / 2,
                -10000,
                10000
            );
            previewCamera.zoom = 1;
        } else {
            previewCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
        }
        const newPos = target.clone().add(direction.multiplyScalar(distance));
        previewCamera.position.copy(newPos);
        previewCamera.lookAt(target);
        previewCamera.updateProjectionMatrix();
    }

    function setPreviewAngle(angle) {
        const size = nbtData.size || [16, 16, 16];
        const target = new THREE.Vector3(size[0] * 8, size[1] * 8, size[2] * 8);
        const maxDim = Math.max(size[0], size[1], size[2]);
        const distance = maxDim * 1.5;
        switch (angle) {
            case 'front':
                previewCamera.position.set(target.x, target.y, target.z + distance);
                break;
            case 'back':
                previewCamera.position.set(target.x, target.y, target.z - distance);
                break;
            case 'left':
                previewCamera.position.set(target.x - distance, target.y, target.z);
                break;
            case 'right':
                previewCamera.position.set(target.x + distance, target.y, target.z);
                break;
            case 'top':
                previewCamera.position.set(target.x, target.y + distance, target.z);
                break;
            case 'isometric':
                previewCamera.position.set(
                    target.x + distance,
                    target.y + distance * 0.7,
                    target.z + distance
                );
                break;
        }
        previewCamera.lookAt(target);
        if (previewCamera.isOrthographicCamera) {
            const container = document.getElementById('previewCanvas');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = maxDim * 4;
            previewCamera.left = -frustumSize * aspect / 2;
            previewCamera.right = frustumSize * aspect / 2;
            previewCamera.top = frustumSize / 2;
            previewCamera.bottom = -frustumSize / 2;
            previewCamera.near = -10000;
            previewCamera.far = 10000;
            previewCamera.zoom = 1;
            previewCamera.updateProjectionMatrix();
        }
    }
    async function takeScreenshot() {
        if (!previewRenderer || !previewScene || !previewCamera) return;
        const scaleFactor = 4;
        const originalSize = new THREE.Vector2();
        previewRenderer.getSize(originalSize);
        const originalBackground = previewScene.background;
        const originalClearAlpha = previewRenderer.getClearAlpha();
        const originalClearColor = new THREE.Color();
        previewRenderer.getClearColor(originalClearColor);
        let backgroundCanvas = null;
        if (screenshotBgType === 'transparent') {
            previewScene.background = null;
            previewRenderer.setClearColor(0x000000, 0);
        } else if (screenshotBgType === 'skyColor') {
        } else if (screenshotBgType === 'texture' || screenshotBgType === 'image') {
            previewScene.background = null;
            previewRenderer.setClearColor(0x000000, 0);
        }
        const highResWidth = originalSize.width * scaleFactor;
        const highResHeight = originalSize.height * scaleFactor;
        previewRenderer.setSize(highResWidth, highResHeight);
        previewRenderer.render(previewScene, previewCamera);
        const bbox = getModelScreenBoundingBox(previewScene, previewCamera, highResWidth, highResHeight);
        const canvas = document.createElement('canvas');
        if (bbox && bbox.width > 0 && bbox.height > 0) {
            canvas.width = bbox.width;
            canvas.height = bbox.height;
            const ctx = canvas.getContext('2d');
            if (screenshotBgType === 'texture' || screenshotBgType === 'image') {
                const bgImage = screenshotBgType === 'texture' ? screenshotBgTexture : screenshotBgImage;
                if (bgImage) {
                    drawTiledBackground(ctx, bgImage, canvas.width, canvas.height, screenshotBgScale);
                }
            } else if (screenshotBgType === 'skyColor') {
                const skyColor = document.getElementById('previewSkyColor').value;
                ctx.fillStyle = skyColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.drawImage(previewRenderer.domElement, bbox.x, bbox.y, bbox.width, bbox.height, 0, 0, bbox.width, bbox.height);
        } else {
            canvas.width = highResWidth;
            canvas.height = highResHeight;
            const ctx = canvas.getContext('2d');
            if (screenshotBgType === 'texture' || screenshotBgType === 'image') {
                const bgImage = screenshotBgType === 'texture' ? screenshotBgTexture : screenshotBgImage;
                if (bgImage) {
                    drawTiledBackground(ctx, bgImage, canvas.width, canvas.height, screenshotBgScale);
                }
            } else if (screenshotBgType === 'skyColor') {
                const skyColor = document.getElementById('previewSkyColor').value;
                ctx.fillStyle = skyColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.drawImage(previewRenderer.domElement, 0, 0);
        }
        previewRenderer.setSize(originalSize.width, originalSize.height);
        previewScene.background = originalBackground;
        previewRenderer.setClearColor(originalClearColor, originalClearAlpha);
        const dataUrl = canvas.toDataURL('image/png');
        showScreenshotPreview(dataUrl);
    }

    function showScreenshotPreview(dataUrl) {
        const previewModalHTML = `
<div class="modal-overlay show" id="screenshotPreviewModal" style="z-index: 5000;">
<div class="help-modal" style="max-width: 90%; max-height: 90%; width: auto; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
    <div class="help-modal-header">
        <div class="help-modal-title">Screenshot Preview</div>
        <button class="modal-close" onclick="closeScreenshotPreview()">
            <img src="assets/buttons/exit.png" alt="Close">
        </button>
    </div>
    <div class="help-modal-body" style="text-align: center; padding: 20px; overflow: hidden; display: flex; flex-direction: column; align-items: center;">
        <div style="flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; background: repeating-conic-gradient(#2a2a2a 0% 25%, #1a1a1a 0% 50%) 50% / 20px 20px; border: 2px solid #0a0a0a;">
            <img src="${dataUrl}" style="max-width: 100%; max-height: 60vh; object-fit: contain; image-rendering: pixelated; box-shadow: 0 0 10px rgba(0,0,0,0.5);">
        </div>
        <div style="display: flex; gap: 15px;">
            <button class="minecraft-button" onclick="copyScreenshot('${dataUrl}')">
                <div class="minecraft-button-left-outline"></div>
                <div class="minecraft-button-right-outline"></div>
                <div class="minecraft-button-section">
                    <div class="minecraft-button-name">Copy Image</div>
                </div>
                <div class="minecraft-button-dark-strip"></div>
                <div class="minecraft-button-bottom-outline"></div>
                <div class="minecraft-button-shadow"></div>
            </button>
            <button class="minecraft-button success" onclick="downloadScreenshot('${dataUrl}')">
                <div class="minecraft-button-left-outline"></div>
                <div class="minecraft-button-right-outline"></div>
                <div class="minecraft-button-section">
                    <div class="minecraft-button-name">Save Image</div>
                </div>
                <div class="minecraft-button-dark-strip"></div>
                <div class="minecraft-button-bottom-outline"></div>
                <div class="minecraft-button-shadow"></div>
            </button>
        </div>
    </div>
</div>
</div>
`;
        document.body.insertAdjacentHTML('beforeend', previewModalHTML);
    }
    async function downloadScreenshot(dataUrl) {
        const structureName = nbtInput.files[0]?.name.replace('.nbt', '') || 'structure';
        const fileName = `${structureName}_preview.png`;
        try {
            const response = await fetch(dataUrl);
            const blob = await response.blob();
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        types: [{
                            description: 'PNG Image',
                            accept: {
                                'image/png': ['.png']
                            },
                        }],
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showToast('Screenshot saved!', 'success');
                    closeScreenshotPreview();
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') return;
                    console.warn('File Picker failed, falling back to download link', err);
                }
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Screenshot saved!', 'success');
            closeScreenshotPreview();
        } catch (error) {
            console.error('Save failed:', error);
            showToast('Error saving screenshot', 'error');
        }
    }

    function closeScreenshotPreview() {
        const modal = document.getElementById('screenshotPreviewModal');
        if (modal) modal.remove();
    }

    function getModelScreenBoundingBox(scene, camera, width, height) {
        const min = new THREE.Vector2(Infinity, Infinity);
        const max = new THREE.Vector2(-Infinity, -Infinity);
        const v = new THREE.Vector3();
        let hasVisibleVertices = false;
        scene.traverse((object) => {
            if (object.isMesh && object.visible) {
                const geometry = object.geometry;
                const positionAttribute = geometry.attributes.position;
                for (let i = 0; i < positionAttribute.count; i++) {
                    v.fromBufferAttribute(positionAttribute, i);
                    object.localToWorld(v);
                    v.project(camera);
                    const x = (v.x * 0.5 + 0.5) * width;
                    const y = (-(v.y) * 0.5 + 0.5) * height;
                    min.x = Math.min(min.x, x);
                    min.y = Math.min(min.y, y);
                    max.x = Math.max(max.x, x);
                    max.y = Math.max(max.y, y);
                    hasVisibleVertices = true;
                }
            }
        });
        if (!hasVisibleVertices) return null;
        const padding = 2;
        return {
            x: Math.max(0, Math.floor(min.x - padding)),
            y: Math.max(0, Math.floor(min.y - padding)),
            width: Math.min(width, Math.ceil(max.x + padding)) - Math.max(0, Math.floor(min.x - padding)),
            height: Math.min(height, Math.ceil(max.y + padding)) - Math.max(0, Math.floor(min.y - padding))
        };
    }
    async function populateTextureDropdown() {
        const grid = document.getElementById('screenshotTextureGrid');
        if (!grid) return;
        grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #a0a0a0; padding: 20px;">Loading textures...</div>';
        const allTextures = new Map();
        const allZips = [resourcesZip, ...modZips.map(m => m.zip)];
        for (const zipObj of allZips) {
            const files = Object.keys(zipObj.files);
            for (const filepath of files) {
                if (filepath.includes('/textures/block/') && filepath.endsWith('.png')) {
                    const fileName = filepath.split('/').pop().replace('.png', '');
                    if (!allTextures.has(fileName)) {
                        allTextures.set(fileName, {
                            path: filepath,
                            zip: zipObj
                        });
                    }
                }
            }
        }
        grid.innerHTML = '';
        const sortedTextures = Array.from(allTextures.entries()).sort((a, b) =>
            a[0].localeCompare(b[0])
        );
        for (const [fileName, data] of sortedTextures) {
            const item = document.createElement('div');
            item.className = 'screenshot-texture-item';
            item.dataset.textureName = fileName.toLowerCase();
            try {
                const file = data.zip.file(data.path);
                if (file) {
                    const blob = await file.async('blob');
                    const url = URL.createObjectURL(blob);
                    item.innerHTML = `
            <img class="screenshot-texture-preview" src="${url}" alt="${fileName}">
            <div class="screenshot-texture-name">${fileName}</div>
        `;
                    item.onclick = async () => {
                        grid.querySelectorAll('.screenshot-texture-item').forEach(el =>
                            el.classList.remove('selected')
                        );
                        item.classList.add('selected');
                        const img = new Image();
                        img.onload = () => {
                            screenshotBgTexture = img;
                            showToast(`Selected texture: ${fileName}`, 'success', {
                                duration: 2000
                            });
                        };
                        img.src = url;
                    };
                    grid.appendChild(item);
                }
            } catch (e) {
                console.error('Error loading texture:', fileName, e);
            }
        }
        if (grid.children.length === 0) {
            grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #a0a0a0; padding: 20px;">No block textures found</div>';
        }
    }

    function filterTextureGrid(searchText) {
        const grid = document.getElementById('screenshotTextureGrid');
        if (!grid) return;
        const search = searchText.toLowerCase().trim();
        const items = grid.querySelectorAll('.screenshot-texture-item');
        items.forEach(item => {
            const textureName = item.dataset.textureName;
            if (search === '' || textureName.includes(search)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        });
    }
    async function updateScreenshotBgType(type) {
        screenshotBgType = type;
        const textureGroup = document.getElementById('textureSelectGroup');
        const imageGroup = document.getElementById('imageUploadGroup');
        const scaleGroup = document.getElementById('bgScaleGroup');
        textureGroup.style.display = 'none';
        imageGroup.style.display = 'none';
        scaleGroup.style.display = 'none';
        if (type === 'texture') {
            textureGroup.style.display = 'block';
            scaleGroup.style.display = 'block';
        } else if (type === 'image') {
            imageGroup.style.display = 'block';
            scaleGroup.style.display = 'block';
        }
    }
    async function handleScreenshotImageUpload(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                screenshotBgImage = img;
                document.getElementById('imageFileName').textContent = file.name;
                showToast('Background image loaded', 'success');
            };
            img.onerror = () => {
                showToast('Error loading image', 'error');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function updateBgScale(value) {
        screenshotBgScale = parseFloat(value);
        document.getElementById('bgScaleValue').textContent = value;
    }

    function drawTiledBackground(ctx, image, width, height, scale) {
        ctx.imageSmoothingEnabled = false;
        const baseSize = 300;
        const scaledWidth = baseSize * scale;
        const scaledHeight = (baseSize * image.height / image.width) * scale;
        const tilesX = Math.ceil(width / scaledWidth);
        const tilesY = Math.ceil(height / scaledHeight);
        for (let y = 0; y < tilesY; y++) {
            for (let x = 0; x < tilesX; x++) {
                ctx.drawImage(
                    image,
                    x * scaledWidth,
                    y * scaledHeight,
                    scaledWidth,
                    scaledHeight
                );
            }
        }
    }
    async function copyScreenshot(dataUrl) {
        try {
            const response = await fetch(dataUrl);
            const blob = await response.blob();
            await navigator.clipboard.write([
                new ClipboardItem({
                    'image/png': blob
                })
            ]);
            showToast('Screenshot copied to clipboard!', 'success');
            closeScreenshotPreview();
        } catch (error) {
            console.error('Copy failed:', error);
            showToast('Failed to copy screenshot. Try saving instead.', 'error');
        }
    }
    const tintColors = {
        grass: 0x7cbd6b,
        foliage: 0x6ba861,
        water: 0x3F76E4
    };

    function updateTintColor(type, colorHex) {
        const colorValue = parseInt(colorHex.replace('#', ''), 16);
        tintColors[type] = colorValue;
        previewScene.traverse((object) => {
            if (object.isMesh && object.userData.tintType === type) {
                const color = new THREE.Color(colorValue);
                if (Array.isArray(object.material)) {
                    object.material.forEach(mat => {
                        if (mat.userData.hasTint) {
                            mat.color.copy(color);
                        }
                    });
                } else if (object.material.userData.hasTint) {
                    object.material.color.copy(color);
                }
            }
        });
    }

    function getTintType(blockName) {
        if (blockName.includes('grass') || blockName.includes('fern') || blockName.includes('tall_grass')) {
            return 'grass';
        }
        if (blockName.includes('leaves') || blockName.includes('vine')) {
            return 'foliage';
        }
        if (blockName.includes('water')) {
            return 'water';
        }
        return null;
    }
</script>
</body>
</html>